//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.1.5.0 (NJsonSchema v10.0.27.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

#pragma warning disable 108 // Disable "CS0108 '{derivedDto}.ToJson()' hides inherited member '{dtoBase}.ToJson()'. Use the new keyword if hiding was intended."
#pragma warning disable 114 // Disable "CS0114 '{derivedDto}.RaisePropertyChanged(String)' hides inherited member 'dtoBase.RaisePropertyChanged(String)'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword."
#pragma warning disable 472 // Disable "CS0472 The result of the expression is always 'false' since a value of type 'Int32' is never equal to 'null' of type 'Int32?'
#pragma warning disable 1573 // Disable "CS1573 Parameter '...' has no matching param tag in the XML comment for ...
#pragma warning disable 1591 // Disable "CS1591 Missing XML comment for publicly visible type or member ..."

namespace NginxCSharp
{
    using System = global::System;
    
    
    public partial interface IClient
    {
        /// <summary>Return list of root endpoints</summary>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetAPIEndpointsAsync();
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return list of root endpoints</summary>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetAPIEndpointsAsync(System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Return status of nginx running instance</summary>
        /// <param name="fields">Limits which fields of nginx running instance will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<NginxObject> GetNginxAsync(string fields);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return status of nginx running instance</summary>
        /// <param name="fields">Limits which fields of nginx running instance will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<NginxObject> GetNginxAsync(string fields, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Return nginx processes status</summary>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Processes> GetProcessesAsync();
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return nginx processes status</summary>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Processes> GetProcessesAsync(System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Reset nginx processes statistics</summary>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteProcessesAsync();
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Reset nginx processes statistics</summary>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteProcessesAsync(System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Return client connections statistics</summary>
        /// <param name="fields">Limits which fields of the connections statistics will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Connections> GetConnectionsAsync(string fields);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return client connections statistics</summary>
        /// <param name="fields">Limits which fields of the connections statistics will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Connections> GetConnectionsAsync(string fields, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Reset client connections statistics</summary>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteConnectionsAsync();
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Reset client connections statistics</summary>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteConnectionsAsync(System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Return status of all slabs</summary>
        /// <param name="fields">Limits which fields of slab zones will be output. If the “&lt;literal&gt;fields&lt;/literal&gt;” value is empty, then only zone names will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, SlabZone>> GetSlabsAsync(string fields);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return status of all slabs</summary>
        /// <param name="fields">Limits which fields of slab zones will be output. If the “&lt;literal&gt;fields&lt;/literal&gt;” value is empty, then only zone names will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, SlabZone>> GetSlabsAsync(string fields, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Return status of a slab</summary>
        /// <param name="fields">Limits which fields of the slab zone will be output.</param>
        /// <param name="slabZoneName">The name of the shared memory zone with slab allocator.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SlabZone> GetSlabZoneAsync(string fields, string slabZoneName);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return status of a slab</summary>
        /// <param name="fields">Limits which fields of the slab zone will be output.</param>
        /// <param name="slabZoneName">The name of the shared memory zone with slab allocator.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SlabZone> GetSlabZoneAsync(string fields, string slabZoneName, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Reset slab statistics</summary>
        /// <param name="slabZoneName">The name of the shared memory zone with slab allocator.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteSlabZoneStatsAsync(string slabZoneName);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Reset slab statistics</summary>
        /// <param name="slabZoneName">The name of the shared memory zone with slab allocator.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteSlabZoneStatsAsync(string slabZoneName, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Return list of HTTP-related endpoints</summary>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetHttpAsync();
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return list of HTTP-related endpoints</summary>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetHttpAsync(System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Return HTTP requests statistics</summary>
        /// <param name="fields">Limits which fields of client HTTP requests statistics will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<HTTPRequests> GetHttpRequestsAsync(string fields);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return HTTP requests statistics</summary>
        /// <param name="fields">Limits which fields of client HTTP requests statistics will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<HTTPRequests> GetHttpRequestsAsync(string fields, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Reset HTTP requests statistics</summary>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteHttpRequestsAsync();
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Reset HTTP requests statistics</summary>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteHttpRequestsAsync(System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Return status of all HTTP server zones</summary>
        /// <param name="fields">Limits which fields of server zones will be output. If the “&lt;literal&gt;fields&lt;/literal&gt;” value is empty, then only server zone names will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, HTTPServerZone>> GetHttpServerZonesAsync(string fields);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return status of all HTTP server zones</summary>
        /// <param name="fields">Limits which fields of server zones will be output. If the “&lt;literal&gt;fields&lt;/literal&gt;” value is empty, then only server zone names will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, HTTPServerZone>> GetHttpServerZonesAsync(string fields, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Return status of an HTTP server zone</summary>
        /// <param name="fields">Limits which fields of the server zone will be output.</param>
        /// <param name="httpServerZoneName">The name of an HTTP server zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<HTTPServerZone> GetHttpServerZoneAsync(string fields, string httpServerZoneName);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return status of an HTTP server zone</summary>
        /// <param name="fields">Limits which fields of the server zone will be output.</param>
        /// <param name="httpServerZoneName">The name of an HTTP server zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<HTTPServerZone> GetHttpServerZoneAsync(string fields, string httpServerZoneName, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Reset statistics for an HTTP server zone</summary>
        /// <param name="httpServerZoneName">The name of an HTTP server zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteHttpServerZoneStatAsync(string httpServerZoneName);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Reset statistics for an HTTP server zone</summary>
        /// <param name="httpServerZoneName">The name of an HTTP server zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteHttpServerZoneStatAsync(string httpServerZoneName, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Return status of all HTTP location zones</summary>
        /// <param name="fields">Limits which fields of location zones will be output. If the “&lt;literal&gt;fields&lt;/literal&gt;” value is empty, then only zone names will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, HTTPLocationZone>> GetHttpLocationZonesAsync(string fields);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return status of all HTTP location zones</summary>
        /// <param name="fields">Limits which fields of location zones will be output. If the “&lt;literal&gt;fields&lt;/literal&gt;” value is empty, then only zone names will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, HTTPLocationZone>> GetHttpLocationZonesAsync(string fields, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Return status of an HTTP location zone</summary>
        /// <param name="fields">Limits which fields of the location zone will be output.</param>
        /// <param name="httpLocationZoneName">The name of an HTTP [location zone](https://nginx.org/en/docs/http/ngx_http_api_module.html#status_zone_location).</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<HTTPLocationZone> GetHttpLocationZoneAsync(string fields, string httpLocationZoneName);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return status of an HTTP location zone</summary>
        /// <param name="fields">Limits which fields of the location zone will be output.</param>
        /// <param name="httpLocationZoneName">The name of an HTTP [location zone](https://nginx.org/en/docs/http/ngx_http_api_module.html#status_zone_location).</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<HTTPLocationZone> GetHttpLocationZoneAsync(string fields, string httpLocationZoneName, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Reset statistics for a location zone.</summary>
        /// <param name="httpLocationZoneName">The name of an HTTP [location zone](https://nginx.org/en/docs/http/ngx_http_api_module.html#status_zone_location).</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteHttpLocationZoneStatAsync(string httpLocationZoneName);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Reset statistics for a location zone.</summary>
        /// <param name="httpLocationZoneName">The name of an HTTP [location zone](https://nginx.org/en/docs/http/ngx_http_api_module.html#status_zone_location).</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteHttpLocationZoneStatAsync(string httpLocationZoneName, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Return status of all caches</summary>
        /// <param name="fields">Limits which fields of cache zones will be output. If the “&lt;literal&gt;fields&lt;/literal&gt;” value is empty, then only names of cache zones will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, HTTPCache>> GetHttpCachesAsync(string fields);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return status of all caches</summary>
        /// <param name="fields">Limits which fields of cache zones will be output. If the “&lt;literal&gt;fields&lt;/literal&gt;” value is empty, then only names of cache zones will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, HTTPCache>> GetHttpCachesAsync(string fields, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Return status of a cache</summary>
        /// <param name="fields">Limits which fields of the cache zone will be output.</param>
        /// <param name="httpCacheZoneName">The name of the cache zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<HTTPCache> GetHttpCacheZoneAsync(string fields, string httpCacheZoneName);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return status of a cache</summary>
        /// <param name="fields">Limits which fields of the cache zone will be output.</param>
        /// <param name="httpCacheZoneName">The name of the cache zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<HTTPCache> GetHttpCacheZoneAsync(string fields, string httpCacheZoneName, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Reset cache statistics</summary>
        /// <param name="httpCacheZoneName">The name of the cache zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteHttpCacheZoneStatAsync(string httpCacheZoneName);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Reset cache statistics</summary>
        /// <param name="httpCacheZoneName">The name of the cache zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteHttpCacheZoneStatAsync(string httpCacheZoneName, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Return status of all HTTP limit_conn zones</summary>
        /// <param name="fields">Limits which fields of limit_conn zones will be output. If the “&lt;literal&gt;fields&lt;/literal&gt;” value is empty, then only zone names will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, HTTPLimitConnZone>> GetHttpLimitConnZonesAsync(string fields);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return status of all HTTP limit_conn zones</summary>
        /// <param name="fields">Limits which fields of limit_conn zones will be output. If the “&lt;literal&gt;fields&lt;/literal&gt;” value is empty, then only zone names will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, HTTPLimitConnZone>> GetHttpLimitConnZonesAsync(string fields, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Return status of an HTTP limit_conn zone</summary>
        /// <param name="fields">Limits which fields of the [limit_conn zone](https://nginx.org/en/docs/http/ngx_http_limit_conn_module.html#limit_conn_zone) will be output.</param>
        /// <param name="httpLimitConnZoneName">The name of a [limit_conn zone](https://nginx.org/en/docs/http/ngx_http_limit_conn_module.html#limit_conn_zone).</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<HTTPLimitConnZone> GetHttpLimitConnZoneAsync(string fields, string httpLimitConnZoneName);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return status of an HTTP limit_conn zone</summary>
        /// <param name="fields">Limits which fields of the [limit_conn zone](https://nginx.org/en/docs/http/ngx_http_limit_conn_module.html#limit_conn_zone) will be output.</param>
        /// <param name="httpLimitConnZoneName">The name of a [limit_conn zone](https://nginx.org/en/docs/http/ngx_http_limit_conn_module.html#limit_conn_zone).</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<HTTPLimitConnZone> GetHttpLimitConnZoneAsync(string fields, string httpLimitConnZoneName, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Reset statistics for an HTTP limit_conn zone</summary>
        /// <param name="httpLimitConnZoneName">The name of a [limit_conn zone](https://nginx.org/en/docs/http/ngx_http_limit_conn_module.html#limit_conn_zone).</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteHttpLimitConnZoneStatAsync(string httpLimitConnZoneName);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Reset statistics for an HTTP limit_conn zone</summary>
        /// <param name="httpLimitConnZoneName">The name of a [limit_conn zone](https://nginx.org/en/docs/http/ngx_http_limit_conn_module.html#limit_conn_zone).</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteHttpLimitConnZoneStatAsync(string httpLimitConnZoneName, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Return status of all HTTP limit_req zones</summary>
        /// <param name="fields">Limits which fields of limit_req zones will be output. If the “&lt;literal&gt;fields&lt;/literal&gt;” value is empty, then only zone names will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, HTTPLimitReqZone>> GetHttpLimitReqZonesAsync(string fields);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return status of all HTTP limit_req zones</summary>
        /// <param name="fields">Limits which fields of limit_req zones will be output. If the “&lt;literal&gt;fields&lt;/literal&gt;” value is empty, then only zone names will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, HTTPLimitReqZone>> GetHttpLimitReqZonesAsync(string fields, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Return status of an HTTP limit_req zone</summary>
        /// <param name="fields">Limits which fields of the [limit_req zone](https://nginx.org/en/docs/http/ngx_http_limit_req_module.html#limit_req_zone) will be output.</param>
        /// <param name="httpLimitReqZoneName">The name of a [limit_req zone](https://nginx.org/en/docs/http/ngx_http_limit_req_module.html#limit_req_zone).</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<HTTPLimitReqZone> GetHttpLimitReqZoneAsync(string fields, string httpLimitReqZoneName);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return status of an HTTP limit_req zone</summary>
        /// <param name="fields">Limits which fields of the [limit_req zone](https://nginx.org/en/docs/http/ngx_http_limit_req_module.html#limit_req_zone) will be output.</param>
        /// <param name="httpLimitReqZoneName">The name of a [limit_req zone](https://nginx.org/en/docs/http/ngx_http_limit_req_module.html#limit_req_zone).</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<HTTPLimitReqZone> GetHttpLimitReqZoneAsync(string fields, string httpLimitReqZoneName, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Reset statistics for an HTTP limit_req zone</summary>
        /// <param name="httpLimitReqZoneName">The name of a [limit_req zone](https://nginx.org/en/docs/http/ngx_http_limit_req_module.html#limit_req_zone).</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteHttpLimitReqZoneStatAsync(string httpLimitReqZoneName);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Reset statistics for an HTTP limit_req zone</summary>
        /// <param name="httpLimitReqZoneName">The name of a [limit_req zone](https://nginx.org/en/docs/http/ngx_http_limit_req_module.html#limit_req_zone).</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteHttpLimitReqZoneStatAsync(string httpLimitReqZoneName, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Return status of all HTTP upstream server groups</summary>
        /// <param name="fields">Limits which fields of upstream server groups will be output. If the “&lt;literal&gt;fields&lt;/literal&gt;” value is empty, only names of upstreams will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, HTTPUpstream>> GetHttpUpstreamsAsync(string fields);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return status of all HTTP upstream server groups</summary>
        /// <param name="fields">Limits which fields of upstream server groups will be output. If the “&lt;literal&gt;fields&lt;/literal&gt;” value is empty, only names of upstreams will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, HTTPUpstream>> GetHttpUpstreamsAsync(string fields, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Return status of an HTTP upstream server group</summary>
        /// <param name="fields">Limits which fields of the upstream server group will be output.</param>
        /// <param name="httpUpstreamName">The name of an HTTP upstream server group.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<HTTPUpstream> GetHttpUpstreamNameAsync(string fields, string httpUpstreamName);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return status of an HTTP upstream server group</summary>
        /// <param name="fields">Limits which fields of the upstream server group will be output.</param>
        /// <param name="httpUpstreamName">The name of an HTTP upstream server group.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<HTTPUpstream> GetHttpUpstreamNameAsync(string fields, string httpUpstreamName, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Reset statistics of an HTTP upstream server group</summary>
        /// <param name="httpUpstreamName">The name of an HTTP upstream server group.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteHttpUpstreamStatAsync(string httpUpstreamName);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Reset statistics of an HTTP upstream server group</summary>
        /// <param name="httpUpstreamName">The name of an HTTP upstream server group.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteHttpUpstreamStatAsync(string httpUpstreamName, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Return configuration of all servers in an HTTP upstream server group</summary>
        /// <param name="httpUpstreamName">The name of an upstream server group.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<HTTPUpstreamConfServer>> GetHttpUpstreamServersAsync(string httpUpstreamName);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return configuration of all servers in an HTTP upstream server group</summary>
        /// <param name="httpUpstreamName">The name of an upstream server group.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<HTTPUpstreamConfServer>> GetHttpUpstreamServersAsync(string httpUpstreamName, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Add a server to an HTTP upstream server group</summary>
        /// <param name="postHttpUpstreamServer">Address of a new server and other optional parameters in the JSON format. The “*ID*”, “*backup*”, and “*service*” parameters cannot be changed.</param>
        /// <param name="httpUpstreamName">The name of an upstream server group.</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<HTTPUpstreamConfServer> PostHttpUpstreamServerAsync(HTTPUpstreamConfServer postHttpUpstreamServer, string httpUpstreamName);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Add a server to an HTTP upstream server group</summary>
        /// <param name="postHttpUpstreamServer">Address of a new server and other optional parameters in the JSON format. The “*ID*”, “*backup*”, and “*service*” parameters cannot be changed.</param>
        /// <param name="httpUpstreamName">The name of an upstream server group.</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<HTTPUpstreamConfServer> PostHttpUpstreamServerAsync(HTTPUpstreamConfServer postHttpUpstreamServer, string httpUpstreamName, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Return configuration of a server in an HTTP upstream server group</summary>
        /// <param name="httpUpstreamName">The name of the upstream server group.</param>
        /// <param name="httpUpstreamServerId">The ID of the server.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<HTTPUpstreamConfServer> GetHttpUpstreamPeerAsync(string httpUpstreamName, string httpUpstreamServerId);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return configuration of a server in an HTTP upstream server group</summary>
        /// <param name="httpUpstreamName">The name of the upstream server group.</param>
        /// <param name="httpUpstreamServerId">The ID of the server.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<HTTPUpstreamConfServer> GetHttpUpstreamPeerAsync(string httpUpstreamName, string httpUpstreamServerId, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Modify a server in an HTTP upstream server group</summary>
        /// <param name="patchHttpUpstreamServer">Server parameters, specified in the JSON format. The “*ID*”, “*backup*”, and “*service*” parameters cannot be changed.</param>
        /// <param name="httpUpstreamName">The name of the upstream server group.</param>
        /// <param name="httpUpstreamServerId">The ID of the server.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<HTTPUpstreamConfServer> PatchHttpUpstreamPeerAsync(HTTPUpstreamConfServer patchHttpUpstreamServer, string httpUpstreamName, string httpUpstreamServerId);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Modify a server in an HTTP upstream server group</summary>
        /// <param name="patchHttpUpstreamServer">Server parameters, specified in the JSON format. The “*ID*”, “*backup*”, and “*service*” parameters cannot be changed.</param>
        /// <param name="httpUpstreamName">The name of the upstream server group.</param>
        /// <param name="httpUpstreamServerId">The ID of the server.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<HTTPUpstreamConfServer> PatchHttpUpstreamPeerAsync(HTTPUpstreamConfServer patchHttpUpstreamServer, string httpUpstreamName, string httpUpstreamServerId, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Remove a server from an HTTP upstream server group</summary>
        /// <param name="httpUpstreamName">The name of the upstream server group.</param>
        /// <param name="httpUpstreamServerId">The ID of the server.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<HTTPUpstreamConfServer>> DeleteHttpUpstreamServerAsync(string httpUpstreamName, string httpUpstreamServerId);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Remove a server from an HTTP upstream server group</summary>
        /// <param name="httpUpstreamName">The name of the upstream server group.</param>
        /// <param name="httpUpstreamServerId">The ID of the server.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<HTTPUpstreamConfServer>> DeleteHttpUpstreamServerAsync(string httpUpstreamName, string httpUpstreamServerId, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Return key-value pairs from all HTTP keyval zones</summary>
        /// <param name="fields">If the “&lt;literal&gt;fields&lt;/literal&gt;” value is empty, then only HTTP keyval zone names will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, HTTPKeyvalZone>> GetHttpKeyvalZonesAsync(string fields);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return key-value pairs from all HTTP keyval zones</summary>
        /// <param name="fields">If the “&lt;literal&gt;fields&lt;/literal&gt;” value is empty, then only HTTP keyval zone names will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, HTTPKeyvalZone>> GetHttpKeyvalZonesAsync(string fields, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Return key-value pairs from an HTTP keyval zone</summary>
        /// <param name="key">Get a particular key-value pair from the HTTP keyval zone.</param>
        /// <param name="httpKeyvalZoneName">The name of an HTTP keyval shared memory zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<HTTPKeyvalZone> GetHttpKeyvalZoneKeysValuesAsync(string key, string httpKeyvalZoneName);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return key-value pairs from an HTTP keyval zone</summary>
        /// <param name="key">Get a particular key-value pair from the HTTP keyval zone.</param>
        /// <param name="httpKeyvalZoneName">The name of an HTTP keyval shared memory zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<HTTPKeyvalZone> GetHttpKeyvalZoneKeysValuesAsync(string key, string httpKeyvalZoneName, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Add a key-value pair to the HTTP keyval zone</summary>
        /// <param name="key_value">A key-value pair is specified in the JSON format. Several key-value pairs can be entered if the HTTP keyval shared memory zone is empty. Expiration time in milliseconds can be specified for a key-value pair with the *expire* parameter which overrides the [*timeout*](https://nginx.org/en/docs/http/ngx_http_keyval_module.html#keyval_timeout) parameter of the &lt;a href="https://nginx.org/en/docs/http/ngx_http_keyval_module.html#keyval_zone"&gt;keyval_zone&lt;/a&gt; directive.</param>
        /// <param name="httpKeyvalZoneName">The name of an HTTP keyval shared memory zone.</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task PostHttpKeyvalZoneDataAsync(HTTPKeyvalZonePostPatch key_value, string httpKeyvalZoneName);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Add a key-value pair to the HTTP keyval zone</summary>
        /// <param name="key_value">A key-value pair is specified in the JSON format. Several key-value pairs can be entered if the HTTP keyval shared memory zone is empty. Expiration time in milliseconds can be specified for a key-value pair with the *expire* parameter which overrides the [*timeout*](https://nginx.org/en/docs/http/ngx_http_keyval_module.html#keyval_timeout) parameter of the &lt;a href="https://nginx.org/en/docs/http/ngx_http_keyval_module.html#keyval_zone"&gt;keyval_zone&lt;/a&gt; directive.</param>
        /// <param name="httpKeyvalZoneName">The name of an HTTP keyval shared memory zone.</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task PostHttpKeyvalZoneDataAsync(HTTPKeyvalZonePostPatch key_value, string httpKeyvalZoneName, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Modify a key-value or delete a key</summary>
        /// <param name="httpKeyvalZoneKeyValue">A new value for the key is specified in the JSON format.</param>
        /// <param name="httpKeyvalZoneName">The name of an HTTP keyval shared memory zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task PatchHttpKeyvalZoneKeyValueAsync(HTTPKeyvalZonePostPatch httpKeyvalZoneKeyValue, string httpKeyvalZoneName);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Modify a key-value or delete a key</summary>
        /// <param name="httpKeyvalZoneKeyValue">A new value for the key is specified in the JSON format.</param>
        /// <param name="httpKeyvalZoneName">The name of an HTTP keyval shared memory zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task PatchHttpKeyvalZoneKeyValueAsync(HTTPKeyvalZonePostPatch httpKeyvalZoneKeyValue, string httpKeyvalZoneName, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Empty the HTTP keyval zone</summary>
        /// <param name="httpKeyvalZoneName">The name of an HTTP keyval shared memory zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteHttpKeyvalZoneDataAsync(string httpKeyvalZoneName);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Empty the HTTP keyval zone</summary>
        /// <param name="httpKeyvalZoneName">The name of an HTTP keyval shared memory zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteHttpKeyvalZoneDataAsync(string httpKeyvalZoneName, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Return list of stream-related endpoints</summary>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetStreamAsync();
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return list of stream-related endpoints</summary>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetStreamAsync(System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Return status of all stream server zones</summary>
        /// <param name="fields">Limits which fields of server zones will be output. If the “&lt;literal&gt;fields&lt;/literal&gt;” value is empty, then only server zone names will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, StreamServerZone>> GetStreamServerZonesAsync(string fields);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return status of all stream server zones</summary>
        /// <param name="fields">Limits which fields of server zones will be output. If the “&lt;literal&gt;fields&lt;/literal&gt;” value is empty, then only server zone names will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, StreamServerZone>> GetStreamServerZonesAsync(string fields, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Return status of a stream server zone</summary>
        /// <param name="fields">Limits which fields of the server zone will be output.</param>
        /// <param name="streamServerZoneName">The name of a stream server zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<StreamServerZone> GetStreamServerZoneAsync(string fields, string streamServerZoneName);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return status of a stream server zone</summary>
        /// <param name="fields">Limits which fields of the server zone will be output.</param>
        /// <param name="streamServerZoneName">The name of a stream server zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<StreamServerZone> GetStreamServerZoneAsync(string fields, string streamServerZoneName, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Reset statistics for a stream server zone</summary>
        /// <param name="streamServerZoneName">The name of a stream server zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteStreamServerZoneStatAsync(string streamServerZoneName);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Reset statistics for a stream server zone</summary>
        /// <param name="streamServerZoneName">The name of a stream server zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteStreamServerZoneStatAsync(string streamServerZoneName, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Return status of all stream limit_conn zones</summary>
        /// <param name="fields">Limits which fields of limit_conn zones will be output. If the “&lt;literal&gt;fields&lt;/literal&gt;” value is empty, then only zone names will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, StreamLimitConnZone>> GetStreamLimitConnZonesAsync(string fields);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return status of all stream limit_conn zones</summary>
        /// <param name="fields">Limits which fields of limit_conn zones will be output. If the “&lt;literal&gt;fields&lt;/literal&gt;” value is empty, then only zone names will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, StreamLimitConnZone>> GetStreamLimitConnZonesAsync(string fields, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Return status of an stream limit_conn zone</summary>
        /// <param name="fields">Limits which fields of the [limit_conn zone](https://nginx.org/en/docs/stream/ngx_stream_limit_conn_module.html#limit_conn_zone) will be output.</param>
        /// <param name="streamLimitConnZoneName">The name of a [limit_conn zone](https://nginx.org/en/docs/stream/ngx_stream_limit_conn_module.html#limit_conn_zone).</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<StreamLimitConnZone> GetStreamLimitConnZoneAsync(string fields, string streamLimitConnZoneName);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return status of an stream limit_conn zone</summary>
        /// <param name="fields">Limits which fields of the [limit_conn zone](https://nginx.org/en/docs/stream/ngx_stream_limit_conn_module.html#limit_conn_zone) will be output.</param>
        /// <param name="streamLimitConnZoneName">The name of a [limit_conn zone](https://nginx.org/en/docs/stream/ngx_stream_limit_conn_module.html#limit_conn_zone).</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<StreamLimitConnZone> GetStreamLimitConnZoneAsync(string fields, string streamLimitConnZoneName, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Reset statistics for a stream limit_conn zone</summary>
        /// <param name="streamLimitConnZoneName">The name of a [limit_conn zone](https://nginx.org/en/docs/stream/ngx_stream_limit_conn_module.html#limit_conn_zone).</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteStreamLimitConnZoneStatAsync(string streamLimitConnZoneName);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Reset statistics for a stream limit_conn zone</summary>
        /// <param name="streamLimitConnZoneName">The name of a [limit_conn zone](https://nginx.org/en/docs/stream/ngx_stream_limit_conn_module.html#limit_conn_zone).</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteStreamLimitConnZoneStatAsync(string streamLimitConnZoneName, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Return status of all stream upstream server groups</summary>
        /// <param name="fields">Limits which fields of upstream server groups will be output. If the “&lt;literal&gt;fields&lt;/literal&gt;” value is empty, only names of upstreams will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, StreamUpstream>> GetStreamUpstreamsAsync(string fields);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return status of all stream upstream server groups</summary>
        /// <param name="fields">Limits which fields of upstream server groups will be output. If the “&lt;literal&gt;fields&lt;/literal&gt;” value is empty, only names of upstreams will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, StreamUpstream>> GetStreamUpstreamsAsync(string fields, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Return status of a stream upstream server group</summary>
        /// <param name="fields">Limits which fields of the upstream server group will be output.</param>
        /// <param name="streamUpstreamName">The name of a stream upstream server group.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<StreamUpstream> GetStreamUpstreamAsync(string fields, string streamUpstreamName);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return status of a stream upstream server group</summary>
        /// <param name="fields">Limits which fields of the upstream server group will be output.</param>
        /// <param name="streamUpstreamName">The name of a stream upstream server group.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<StreamUpstream> GetStreamUpstreamAsync(string fields, string streamUpstreamName, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Reset statistics of a stream upstream server group</summary>
        /// <param name="streamUpstreamName">The name of a stream upstream server group.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteStreamUpstreamStatAsync(string streamUpstreamName);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Reset statistics of a stream upstream server group</summary>
        /// <param name="streamUpstreamName">The name of a stream upstream server group.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteStreamUpstreamStatAsync(string streamUpstreamName, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Return configuration of all servers in a stream upstream server group</summary>
        /// <param name="streamUpstreamName">The name of an upstream server group.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<StreamUpstreamConfServer>> GetStreamUpstreamServersAsync(string streamUpstreamName);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return configuration of all servers in a stream upstream server group</summary>
        /// <param name="streamUpstreamName">The name of an upstream server group.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<StreamUpstreamConfServer>> GetStreamUpstreamServersAsync(string streamUpstreamName, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Add a server to a stream upstream server group</summary>
        /// <param name="postStreamUpstreamServer">Address of a new server and other optional parameters in the JSON format. The “*ID*”, “*backup*”, and “*service*” parameters cannot be changed.</param>
        /// <param name="streamUpstreamName">The name of an upstream server group.</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<StreamUpstreamConfServer> PostStreamUpstreamServerAsync(StreamUpstreamConfServer postStreamUpstreamServer, string streamUpstreamName);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Add a server to a stream upstream server group</summary>
        /// <param name="postStreamUpstreamServer">Address of a new server and other optional parameters in the JSON format. The “*ID*”, “*backup*”, and “*service*” parameters cannot be changed.</param>
        /// <param name="streamUpstreamName">The name of an upstream server group.</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<StreamUpstreamConfServer> PostStreamUpstreamServerAsync(StreamUpstreamConfServer postStreamUpstreamServer, string streamUpstreamName, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Return configuration of a server in a stream upstream server group</summary>
        /// <param name="streamUpstreamName">The name of the upstream server group.</param>
        /// <param name="streamUpstreamServerId">The ID of the server.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<StreamUpstreamConfServer> GetStreamUpstreamServerAsync(string streamUpstreamName, string streamUpstreamServerId);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return configuration of a server in a stream upstream server group</summary>
        /// <param name="streamUpstreamName">The name of the upstream server group.</param>
        /// <param name="streamUpstreamServerId">The ID of the server.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<StreamUpstreamConfServer> GetStreamUpstreamServerAsync(string streamUpstreamName, string streamUpstreamServerId, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Modify a server in a stream upstream server group</summary>
        /// <param name="patchStreamUpstreamServer">Server parameters, specified in the JSON format. The “*ID*”, “*backup*”, and “*service*” parameters cannot be changed.</param>
        /// <param name="streamUpstreamName">The name of the upstream server group.</param>
        /// <param name="streamUpstreamServerId">The ID of the server.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<StreamUpstreamConfServer> PatchStreamUpstreamServerAsync(StreamUpstreamConfServer patchStreamUpstreamServer, string streamUpstreamName, string streamUpstreamServerId);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Modify a server in a stream upstream server group</summary>
        /// <param name="patchStreamUpstreamServer">Server parameters, specified in the JSON format. The “*ID*”, “*backup*”, and “*service*” parameters cannot be changed.</param>
        /// <param name="streamUpstreamName">The name of the upstream server group.</param>
        /// <param name="streamUpstreamServerId">The ID of the server.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<StreamUpstreamConfServer> PatchStreamUpstreamServerAsync(StreamUpstreamConfServer patchStreamUpstreamServer, string streamUpstreamName, string streamUpstreamServerId, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Remove a server from a stream upstream server group</summary>
        /// <param name="streamUpstreamName">The name of the upstream server group.</param>
        /// <param name="streamUpstreamServerId">The ID of the server.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<StreamUpstreamConfServer>> DeleteStreamUpstreamServerAsync(string streamUpstreamName, string streamUpstreamServerId);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Remove a server from a stream upstream server group</summary>
        /// <param name="streamUpstreamName">The name of the upstream server group.</param>
        /// <param name="streamUpstreamServerId">The ID of the server.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<StreamUpstreamConfServer>> DeleteStreamUpstreamServerAsync(string streamUpstreamName, string streamUpstreamServerId, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Return key-value pairs from all stream keyval zones</summary>
        /// <param name="fields">If the “&lt;literal&gt;fields&lt;/literal&gt;” value is empty, then only stream keyval zone names will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, StreamKeyvalZone>> GetStreamKeyvalZonesAsync(string fields);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return key-value pairs from all stream keyval zones</summary>
        /// <param name="fields">If the “&lt;literal&gt;fields&lt;/literal&gt;” value is empty, then only stream keyval zone names will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, StreamKeyvalZone>> GetStreamKeyvalZonesAsync(string fields, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Return key-value pairs from a stream keyval zone</summary>
        /// <param name="key">Get a particular key-value pair from the stream keyval zone.</param>
        /// <param name="streamKeyvalZoneName">The name of a stream keyval shared memory zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<StreamKeyvalZone> GetStreamKeyvalZoneKeysValuesAsync(string key, string streamKeyvalZoneName);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return key-value pairs from a stream keyval zone</summary>
        /// <param name="key">Get a particular key-value pair from the stream keyval zone.</param>
        /// <param name="streamKeyvalZoneName">The name of a stream keyval shared memory zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<StreamKeyvalZone> GetStreamKeyvalZoneKeysValuesAsync(string key, string streamKeyvalZoneName, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Add a key-value pair to the stream keyval zone</summary>
        /// <param name="key_value">A key-value pair is specified in the JSON format. Several key-value pairs can be entered if the stream keyval shared memory zone is empty. Expiration time in milliseconds can be specified for a key-value pair with the *expire* parameter which overrides the [*timeout*](https://nginx.org/en/docs/stream/ngx_stream_keyval_module.html#keyval_timeout) parameter of the &lt;a href="https://nginx.org/en/docs/stream/ngx_stream_keyval_module.html#keyval_zone"&gt;keyval_zone&lt;/a&gt; directive.</param>
        /// <param name="streamKeyvalZoneName">The name of a stream keyval shared memory zone.</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task PostStreamKeyvalZoneDataAsync(StreamKeyvalZonePostPatch key_value, string streamKeyvalZoneName);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Add a key-value pair to the stream keyval zone</summary>
        /// <param name="key_value">A key-value pair is specified in the JSON format. Several key-value pairs can be entered if the stream keyval shared memory zone is empty. Expiration time in milliseconds can be specified for a key-value pair with the *expire* parameter which overrides the [*timeout*](https://nginx.org/en/docs/stream/ngx_stream_keyval_module.html#keyval_timeout) parameter of the &lt;a href="https://nginx.org/en/docs/stream/ngx_stream_keyval_module.html#keyval_zone"&gt;keyval_zone&lt;/a&gt; directive.</param>
        /// <param name="streamKeyvalZoneName">The name of a stream keyval shared memory zone.</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task PostStreamKeyvalZoneDataAsync(StreamKeyvalZonePostPatch key_value, string streamKeyvalZoneName, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Modify a key-value or delete a key</summary>
        /// <param name="streamKeyvalZoneKeyValue">A new value for the key is specified in the JSON format.</param>
        /// <param name="streamKeyvalZoneName">The name of a stream keyval shared memory zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task PatchStreamKeyvalZoneKeyValueAsync(StreamKeyvalZonePostPatch streamKeyvalZoneKeyValue, string streamKeyvalZoneName);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Modify a key-value or delete a key</summary>
        /// <param name="streamKeyvalZoneKeyValue">A new value for the key is specified in the JSON format.</param>
        /// <param name="streamKeyvalZoneName">The name of a stream keyval shared memory zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task PatchStreamKeyvalZoneKeyValueAsync(StreamKeyvalZonePostPatch streamKeyvalZoneKeyValue, string streamKeyvalZoneName, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Empty the stream keyval zone</summary>
        /// <param name="streamKeyvalZoneName">The name of a stream keyval shared memory zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteStreamKeyvalZoneDataAsync(string streamKeyvalZoneName);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Empty the stream keyval zone</summary>
        /// <param name="streamKeyvalZoneName">The name of a stream keyval shared memory zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteStreamKeyvalZoneDataAsync(string streamKeyvalZoneName, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Return sync status of a node</summary>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<StreamZoneSync> GetStreamZoneSyncAsync();
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return sync status of a node</summary>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<StreamZoneSync> GetStreamZoneSyncAsync(System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Return status for all resolver zones</summary>
        /// <param name="fields">Limits which fields of resolvers statistics will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, ResolverZone>> GetResolverZonesAsync(string fields);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return status for all resolver zones</summary>
        /// <param name="fields">Limits which fields of resolvers statistics will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, ResolverZone>> GetResolverZonesAsync(string fields, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Return statistics of a resolver zone</summary>
        /// <param name="fields">Limits which fields of the resolver zone will be output (requests, responses, or both).</param>
        /// <param name="resolverZoneName">The name of a resolver zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ResolverZone> GetResolverZoneAsync(string fields, string resolverZoneName);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return statistics of a resolver zone</summary>
        /// <param name="fields">Limits which fields of the resolver zone will be output (requests, responses, or both).</param>
        /// <param name="resolverZoneName">The name of a resolver zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ResolverZone> GetResolverZoneAsync(string fields, string resolverZoneName, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Reset statistics for a resolver zone.</summary>
        /// <param name="resolverZoneName">The name of a resolver zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteResolverZoneStatAsync(string resolverZoneName);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Reset statistics for a resolver zone.</summary>
        /// <param name="resolverZoneName">The name of a resolver zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteResolverZoneStatAsync(string resolverZoneName, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Return SSL statistics</summary>
        /// <param name="fields">Limits which fields of SSL statistics will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SSLObject> GetSslAsync(string fields);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return SSL statistics</summary>
        /// <param name="fields">Limits which fields of SSL statistics will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SSLObject> GetSslAsync(string fields, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Reset SSL statistics</summary>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteSslStatAsync();
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Reset SSL statistics</summary>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteSslStatAsync(System.Threading.CancellationToken cancellationToken);
    
    }
    
    
    public partial class Client : IClient
    {
        private string _baseUrl = "";
        private System.Net.Http.HttpClient _httpClient;
        private System.Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings;
    
        public Client(string baseUrl, System.Net.Http.HttpClient httpClient)
        {
            BaseUrl = baseUrl; 
            _httpClient = httpClient; 
            _settings = new System.Lazy<Newtonsoft.Json.JsonSerializerSettings>(() => 
            {
                var settings = new Newtonsoft.Json.JsonSerializerSettings();
                UpdateJsonSerializerSettings(settings);
                return settings;
            });
        }
    
        public string BaseUrl 
        {
            get { return _baseUrl; }
            set { _baseUrl = value; }
        }
    
        protected Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }
    
        partial void UpdateJsonSerializerSettings(Newtonsoft.Json.JsonSerializerSettings settings);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);
    
        /// <summary>Return list of root endpoints</summary>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetAPIEndpointsAsync()
        {
            return GetAPIEndpointsAsync(System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return list of root endpoints</summary>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetAPIEndpointsAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<string>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(System.Collections.Generic.ICollection<string>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Return status of nginx running instance</summary>
        /// <param name="fields">Limits which fields of nginx running instance will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<NginxObject> GetNginxAsync(string fields)
        {
            return GetNginxAsync(fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return status of nginx running instance</summary>
        /// <param name="fields">Limits which fields of nginx running instance will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<NginxObject> GetNginxAsync(string fields, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/nginx?");
            if (fields != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(fields, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxObject>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(NginxObject);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Return nginx processes status</summary>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<Processes> GetProcessesAsync()
        {
            return GetProcessesAsync(System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return nginx processes status</summary>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<Processes> GetProcessesAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/processes");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Processes>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(Processes);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Reset nginx processes statistics</summary>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteProcessesAsync()
        {
            return DeleteProcessesAsync(System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Reset nginx processes statistics</summary>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteProcessesAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/processes");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204") 
                        {
                            return;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Return client connections statistics</summary>
        /// <param name="fields">Limits which fields of the connections statistics will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<Connections> GetConnectionsAsync(string fields)
        {
            return GetConnectionsAsync(fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return client connections statistics</summary>
        /// <param name="fields">Limits which fields of the connections statistics will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<Connections> GetConnectionsAsync(string fields, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/connections?");
            if (fields != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(fields, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Connections>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(Connections);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Reset client connections statistics</summary>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteConnectionsAsync()
        {
            return DeleteConnectionsAsync(System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Reset client connections statistics</summary>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteConnectionsAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/connections");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204") 
                        {
                            return;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Return status of all slabs</summary>
        /// <param name="fields">Limits which fields of slab zones will be output. If the “&lt;literal&gt;fields&lt;/literal&gt;” value is empty, then only zone names will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, SlabZone>> GetSlabsAsync(string fields)
        {
            return GetSlabsAsync(fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return status of all slabs</summary>
        /// <param name="fields">Limits which fields of slab zones will be output. If the “&lt;literal&gt;fields&lt;/literal&gt;” value is empty, then only zone names will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, SlabZone>> GetSlabsAsync(string fields, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/slabs/?");
            if (fields != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(fields, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.IDictionary<string, SlabZone>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(System.Collections.Generic.IDictionary<string, SlabZone>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Return status of a slab</summary>
        /// <param name="fields">Limits which fields of the slab zone will be output.</param>
        /// <param name="slabZoneName">The name of the shared memory zone with slab allocator.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SlabZone> GetSlabZoneAsync(string fields, string slabZoneName)
        {
            return GetSlabZoneAsync(fields, slabZoneName, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return status of a slab</summary>
        /// <param name="fields">Limits which fields of the slab zone will be output.</param>
        /// <param name="slabZoneName">The name of the shared memory zone with slab allocator.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<SlabZone> GetSlabZoneAsync(string fields, string slabZoneName, System.Threading.CancellationToken cancellationToken)
        {
            if (slabZoneName == null)
                throw new System.ArgumentNullException("slabZoneName");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/slabs/{slabZoneName}?");
            urlBuilder_.Replace("{slabZoneName}", System.Uri.EscapeDataString(ConvertToString(slabZoneName, System.Globalization.CultureInfo.InvariantCulture)));
            if (fields != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(fields, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SlabZone>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "404") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Slab not found (*SlabNotFound*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(SlabZone);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Reset slab statistics</summary>
        /// <param name="slabZoneName">The name of the shared memory zone with slab allocator.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteSlabZoneStatsAsync(string slabZoneName)
        {
            return DeleteSlabZoneStatsAsync(slabZoneName, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Reset slab statistics</summary>
        /// <param name="slabZoneName">The name of the shared memory zone with slab allocator.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteSlabZoneStatsAsync(string slabZoneName, System.Threading.CancellationToken cancellationToken)
        {
            if (slabZoneName == null)
                throw new System.ArgumentNullException("slabZoneName");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/slabs/{slabZoneName}");
            urlBuilder_.Replace("{slabZoneName}", System.Uri.EscapeDataString(ConvertToString(slabZoneName, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204") 
                        {
                            return;
                        }
                        else
                        if (status_ == "404") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Slab not found (*SlabNotFound*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Method disabled (*MethodDisabled*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Return list of HTTP-related endpoints</summary>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetHttpAsync()
        {
            return GetHttpAsync(System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return list of HTTP-related endpoints</summary>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetHttpAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/http/");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<string>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(System.Collections.Generic.ICollection<string>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Return HTTP requests statistics</summary>
        /// <param name="fields">Limits which fields of client HTTP requests statistics will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<HTTPRequests> GetHttpRequestsAsync(string fields)
        {
            return GetHttpRequestsAsync(fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return HTTP requests statistics</summary>
        /// <param name="fields">Limits which fields of client HTTP requests statistics will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<HTTPRequests> GetHttpRequestsAsync(string fields, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/http/requests?");
            if (fields != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(fields, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<HTTPRequests>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(HTTPRequests);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Reset HTTP requests statistics</summary>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteHttpRequestsAsync()
        {
            return DeleteHttpRequestsAsync(System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Reset HTTP requests statistics</summary>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteHttpRequestsAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/http/requests");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204") 
                        {
                            return;
                        }
                        else
                        if (status_ == "405") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Method disabled (*MethodDisabled*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Return status of all HTTP server zones</summary>
        /// <param name="fields">Limits which fields of server zones will be output. If the “&lt;literal&gt;fields&lt;/literal&gt;” value is empty, then only server zone names will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, HTTPServerZone>> GetHttpServerZonesAsync(string fields)
        {
            return GetHttpServerZonesAsync(fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return status of all HTTP server zones</summary>
        /// <param name="fields">Limits which fields of server zones will be output. If the “&lt;literal&gt;fields&lt;/literal&gt;” value is empty, then only server zone names will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, HTTPServerZone>> GetHttpServerZonesAsync(string fields, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/http/server_zones/?");
            if (fields != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(fields, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.IDictionary<string, HTTPServerZone>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(System.Collections.Generic.IDictionary<string, HTTPServerZone>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Return status of an HTTP server zone</summary>
        /// <param name="fields">Limits which fields of the server zone will be output.</param>
        /// <param name="httpServerZoneName">The name of an HTTP server zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<HTTPServerZone> GetHttpServerZoneAsync(string fields, string httpServerZoneName)
        {
            return GetHttpServerZoneAsync(fields, httpServerZoneName, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return status of an HTTP server zone</summary>
        /// <param name="fields">Limits which fields of the server zone will be output.</param>
        /// <param name="httpServerZoneName">The name of an HTTP server zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<HTTPServerZone> GetHttpServerZoneAsync(string fields, string httpServerZoneName, System.Threading.CancellationToken cancellationToken)
        {
            if (httpServerZoneName == null)
                throw new System.ArgumentNullException("httpServerZoneName");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/http/server_zones/{httpServerZoneName}?");
            urlBuilder_.Replace("{httpServerZoneName}", System.Uri.EscapeDataString(ConvertToString(httpServerZoneName, System.Globalization.CultureInfo.InvariantCulture)));
            if (fields != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(fields, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<HTTPServerZone>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "404") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Server zone not found (*ServerZoneNotFound*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(HTTPServerZone);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Reset statistics for an HTTP server zone</summary>
        /// <param name="httpServerZoneName">The name of an HTTP server zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteHttpServerZoneStatAsync(string httpServerZoneName)
        {
            return DeleteHttpServerZoneStatAsync(httpServerZoneName, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Reset statistics for an HTTP server zone</summary>
        /// <param name="httpServerZoneName">The name of an HTTP server zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteHttpServerZoneStatAsync(string httpServerZoneName, System.Threading.CancellationToken cancellationToken)
        {
            if (httpServerZoneName == null)
                throw new System.ArgumentNullException("httpServerZoneName");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/http/server_zones/{httpServerZoneName}");
            urlBuilder_.Replace("{httpServerZoneName}", System.Uri.EscapeDataString(ConvertToString(httpServerZoneName, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204") 
                        {
                            return;
                        }
                        else
                        if (status_ == "404") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Server zone not found (*ServerZoneNotFound*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Method disabled (*MethodDisabled*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Return status of all HTTP location zones</summary>
        /// <param name="fields">Limits which fields of location zones will be output. If the “&lt;literal&gt;fields&lt;/literal&gt;” value is empty, then only zone names will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, HTTPLocationZone>> GetHttpLocationZonesAsync(string fields)
        {
            return GetHttpLocationZonesAsync(fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return status of all HTTP location zones</summary>
        /// <param name="fields">Limits which fields of location zones will be output. If the “&lt;literal&gt;fields&lt;/literal&gt;” value is empty, then only zone names will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, HTTPLocationZone>> GetHttpLocationZonesAsync(string fields, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/http/location_zones/?");
            if (fields != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(fields, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.IDictionary<string, HTTPLocationZone>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(System.Collections.Generic.IDictionary<string, HTTPLocationZone>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Return status of an HTTP location zone</summary>
        /// <param name="fields">Limits which fields of the location zone will be output.</param>
        /// <param name="httpLocationZoneName">The name of an HTTP [location zone](https://nginx.org/en/docs/http/ngx_http_api_module.html#status_zone_location).</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<HTTPLocationZone> GetHttpLocationZoneAsync(string fields, string httpLocationZoneName)
        {
            return GetHttpLocationZoneAsync(fields, httpLocationZoneName, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return status of an HTTP location zone</summary>
        /// <param name="fields">Limits which fields of the location zone will be output.</param>
        /// <param name="httpLocationZoneName">The name of an HTTP [location zone](https://nginx.org/en/docs/http/ngx_http_api_module.html#status_zone_location).</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<HTTPLocationZone> GetHttpLocationZoneAsync(string fields, string httpLocationZoneName, System.Threading.CancellationToken cancellationToken)
        {
            if (httpLocationZoneName == null)
                throw new System.ArgumentNullException("httpLocationZoneName");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/http/location_zones/{httpLocationZoneName}?");
            urlBuilder_.Replace("{httpLocationZoneName}", System.Uri.EscapeDataString(ConvertToString(httpLocationZoneName, System.Globalization.CultureInfo.InvariantCulture)));
            if (fields != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(fields, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<HTTPLocationZone>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "404") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Location zone not found (*LocationZoneNotFound*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(HTTPLocationZone);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Reset statistics for a location zone.</summary>
        /// <param name="httpLocationZoneName">The name of an HTTP [location zone](https://nginx.org/en/docs/http/ngx_http_api_module.html#status_zone_location).</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteHttpLocationZoneStatAsync(string httpLocationZoneName)
        {
            return DeleteHttpLocationZoneStatAsync(httpLocationZoneName, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Reset statistics for a location zone.</summary>
        /// <param name="httpLocationZoneName">The name of an HTTP [location zone](https://nginx.org/en/docs/http/ngx_http_api_module.html#status_zone_location).</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteHttpLocationZoneStatAsync(string httpLocationZoneName, System.Threading.CancellationToken cancellationToken)
        {
            if (httpLocationZoneName == null)
                throw new System.ArgumentNullException("httpLocationZoneName");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/http/location_zones/{httpLocationZoneName}");
            urlBuilder_.Replace("{httpLocationZoneName}", System.Uri.EscapeDataString(ConvertToString(httpLocationZoneName, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204") 
                        {
                            return;
                        }
                        else
                        if (status_ == "404") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Location zone not found (*LocationZoneNotFound*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Method disabled (*MethodDisabled*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Return status of all caches</summary>
        /// <param name="fields">Limits which fields of cache zones will be output. If the “&lt;literal&gt;fields&lt;/literal&gt;” value is empty, then only names of cache zones will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, HTTPCache>> GetHttpCachesAsync(string fields)
        {
            return GetHttpCachesAsync(fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return status of all caches</summary>
        /// <param name="fields">Limits which fields of cache zones will be output. If the “&lt;literal&gt;fields&lt;/literal&gt;” value is empty, then only names of cache zones will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, HTTPCache>> GetHttpCachesAsync(string fields, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/http/caches/?");
            if (fields != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(fields, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.IDictionary<string, HTTPCache>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(System.Collections.Generic.IDictionary<string, HTTPCache>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Return status of a cache</summary>
        /// <param name="fields">Limits which fields of the cache zone will be output.</param>
        /// <param name="httpCacheZoneName">The name of the cache zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<HTTPCache> GetHttpCacheZoneAsync(string fields, string httpCacheZoneName)
        {
            return GetHttpCacheZoneAsync(fields, httpCacheZoneName, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return status of a cache</summary>
        /// <param name="fields">Limits which fields of the cache zone will be output.</param>
        /// <param name="httpCacheZoneName">The name of the cache zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<HTTPCache> GetHttpCacheZoneAsync(string fields, string httpCacheZoneName, System.Threading.CancellationToken cancellationToken)
        {
            if (httpCacheZoneName == null)
                throw new System.ArgumentNullException("httpCacheZoneName");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/http/caches/{httpCacheZoneName}?");
            urlBuilder_.Replace("{httpCacheZoneName}", System.Uri.EscapeDataString(ConvertToString(httpCacheZoneName, System.Globalization.CultureInfo.InvariantCulture)));
            if (fields != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(fields, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<HTTPCache>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "404") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Cache not found (*CacheNotFound*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(HTTPCache);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Reset cache statistics</summary>
        /// <param name="httpCacheZoneName">The name of the cache zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteHttpCacheZoneStatAsync(string httpCacheZoneName)
        {
            return DeleteHttpCacheZoneStatAsync(httpCacheZoneName, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Reset cache statistics</summary>
        /// <param name="httpCacheZoneName">The name of the cache zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteHttpCacheZoneStatAsync(string httpCacheZoneName, System.Threading.CancellationToken cancellationToken)
        {
            if (httpCacheZoneName == null)
                throw new System.ArgumentNullException("httpCacheZoneName");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/http/caches/{httpCacheZoneName}");
            urlBuilder_.Replace("{httpCacheZoneName}", System.Uri.EscapeDataString(ConvertToString(httpCacheZoneName, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204") 
                        {
                            return;
                        }
                        else
                        if (status_ == "404") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Cache not found (*CacheNotFound*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Method disabled (*MethodDisabled*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Return status of all HTTP limit_conn zones</summary>
        /// <param name="fields">Limits which fields of limit_conn zones will be output. If the “&lt;literal&gt;fields&lt;/literal&gt;” value is empty, then only zone names will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, HTTPLimitConnZone>> GetHttpLimitConnZonesAsync(string fields)
        {
            return GetHttpLimitConnZonesAsync(fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return status of all HTTP limit_conn zones</summary>
        /// <param name="fields">Limits which fields of limit_conn zones will be output. If the “&lt;literal&gt;fields&lt;/literal&gt;” value is empty, then only zone names will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, HTTPLimitConnZone>> GetHttpLimitConnZonesAsync(string fields, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/http/limit_conns/?");
            if (fields != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(fields, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.IDictionary<string, HTTPLimitConnZone>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(System.Collections.Generic.IDictionary<string, HTTPLimitConnZone>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Return status of an HTTP limit_conn zone</summary>
        /// <param name="fields">Limits which fields of the [limit_conn zone](https://nginx.org/en/docs/http/ngx_http_limit_conn_module.html#limit_conn_zone) will be output.</param>
        /// <param name="httpLimitConnZoneName">The name of a [limit_conn zone](https://nginx.org/en/docs/http/ngx_http_limit_conn_module.html#limit_conn_zone).</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<HTTPLimitConnZone> GetHttpLimitConnZoneAsync(string fields, string httpLimitConnZoneName)
        {
            return GetHttpLimitConnZoneAsync(fields, httpLimitConnZoneName, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return status of an HTTP limit_conn zone</summary>
        /// <param name="fields">Limits which fields of the [limit_conn zone](https://nginx.org/en/docs/http/ngx_http_limit_conn_module.html#limit_conn_zone) will be output.</param>
        /// <param name="httpLimitConnZoneName">The name of a [limit_conn zone](https://nginx.org/en/docs/http/ngx_http_limit_conn_module.html#limit_conn_zone).</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<HTTPLimitConnZone> GetHttpLimitConnZoneAsync(string fields, string httpLimitConnZoneName, System.Threading.CancellationToken cancellationToken)
        {
            if (httpLimitConnZoneName == null)
                throw new System.ArgumentNullException("httpLimitConnZoneName");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/http/limit_conns/{httpLimitConnZoneName}?");
            urlBuilder_.Replace("{httpLimitConnZoneName}", System.Uri.EscapeDataString(ConvertToString(httpLimitConnZoneName, System.Globalization.CultureInfo.InvariantCulture)));
            if (fields != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(fields, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<HTTPLimitConnZone>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "404") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("limit_conn not found (*LimitConnNotFound*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(HTTPLimitConnZone);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Reset statistics for an HTTP limit_conn zone</summary>
        /// <param name="httpLimitConnZoneName">The name of a [limit_conn zone](https://nginx.org/en/docs/http/ngx_http_limit_conn_module.html#limit_conn_zone).</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteHttpLimitConnZoneStatAsync(string httpLimitConnZoneName)
        {
            return DeleteHttpLimitConnZoneStatAsync(httpLimitConnZoneName, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Reset statistics for an HTTP limit_conn zone</summary>
        /// <param name="httpLimitConnZoneName">The name of a [limit_conn zone](https://nginx.org/en/docs/http/ngx_http_limit_conn_module.html#limit_conn_zone).</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteHttpLimitConnZoneStatAsync(string httpLimitConnZoneName, System.Threading.CancellationToken cancellationToken)
        {
            if (httpLimitConnZoneName == null)
                throw new System.ArgumentNullException("httpLimitConnZoneName");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/http/limit_conns/{httpLimitConnZoneName}");
            urlBuilder_.Replace("{httpLimitConnZoneName}", System.Uri.EscapeDataString(ConvertToString(httpLimitConnZoneName, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204") 
                        {
                            return;
                        }
                        else
                        if (status_ == "404") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("limit_conn not found (*LimitConnNotFound*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Method disabled (*MethodDisabled*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Return status of all HTTP limit_req zones</summary>
        /// <param name="fields">Limits which fields of limit_req zones will be output. If the “&lt;literal&gt;fields&lt;/literal&gt;” value is empty, then only zone names will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, HTTPLimitReqZone>> GetHttpLimitReqZonesAsync(string fields)
        {
            return GetHttpLimitReqZonesAsync(fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return status of all HTTP limit_req zones</summary>
        /// <param name="fields">Limits which fields of limit_req zones will be output. If the “&lt;literal&gt;fields&lt;/literal&gt;” value is empty, then only zone names will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, HTTPLimitReqZone>> GetHttpLimitReqZonesAsync(string fields, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/http/limit_reqs/?");
            if (fields != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(fields, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.IDictionary<string, HTTPLimitReqZone>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(System.Collections.Generic.IDictionary<string, HTTPLimitReqZone>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Return status of an HTTP limit_req zone</summary>
        /// <param name="fields">Limits which fields of the [limit_req zone](https://nginx.org/en/docs/http/ngx_http_limit_req_module.html#limit_req_zone) will be output.</param>
        /// <param name="httpLimitReqZoneName">The name of a [limit_req zone](https://nginx.org/en/docs/http/ngx_http_limit_req_module.html#limit_req_zone).</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<HTTPLimitReqZone> GetHttpLimitReqZoneAsync(string fields, string httpLimitReqZoneName)
        {
            return GetHttpLimitReqZoneAsync(fields, httpLimitReqZoneName, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return status of an HTTP limit_req zone</summary>
        /// <param name="fields">Limits which fields of the [limit_req zone](https://nginx.org/en/docs/http/ngx_http_limit_req_module.html#limit_req_zone) will be output.</param>
        /// <param name="httpLimitReqZoneName">The name of a [limit_req zone](https://nginx.org/en/docs/http/ngx_http_limit_req_module.html#limit_req_zone).</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<HTTPLimitReqZone> GetHttpLimitReqZoneAsync(string fields, string httpLimitReqZoneName, System.Threading.CancellationToken cancellationToken)
        {
            if (httpLimitReqZoneName == null)
                throw new System.ArgumentNullException("httpLimitReqZoneName");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/http/limit_reqs/{httpLimitReqZoneName}?");
            urlBuilder_.Replace("{httpLimitReqZoneName}", System.Uri.EscapeDataString(ConvertToString(httpLimitReqZoneName, System.Globalization.CultureInfo.InvariantCulture)));
            if (fields != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(fields, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<HTTPLimitReqZone>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "404") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("limit_req not found (*LimitReqNotFound*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(HTTPLimitReqZone);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Reset statistics for an HTTP limit_req zone</summary>
        /// <param name="httpLimitReqZoneName">The name of a [limit_req zone](https://nginx.org/en/docs/http/ngx_http_limit_req_module.html#limit_req_zone).</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteHttpLimitReqZoneStatAsync(string httpLimitReqZoneName)
        {
            return DeleteHttpLimitReqZoneStatAsync(httpLimitReqZoneName, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Reset statistics for an HTTP limit_req zone</summary>
        /// <param name="httpLimitReqZoneName">The name of a [limit_req zone](https://nginx.org/en/docs/http/ngx_http_limit_req_module.html#limit_req_zone).</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteHttpLimitReqZoneStatAsync(string httpLimitReqZoneName, System.Threading.CancellationToken cancellationToken)
        {
            if (httpLimitReqZoneName == null)
                throw new System.ArgumentNullException("httpLimitReqZoneName");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/http/limit_reqs/{httpLimitReqZoneName}");
            urlBuilder_.Replace("{httpLimitReqZoneName}", System.Uri.EscapeDataString(ConvertToString(httpLimitReqZoneName, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204") 
                        {
                            return;
                        }
                        else
                        if (status_ == "404") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("limit_req not found (*LimitReqNotFound*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Method disabled (*MethodDisabled*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Return status of all HTTP upstream server groups</summary>
        /// <param name="fields">Limits which fields of upstream server groups will be output. If the “&lt;literal&gt;fields&lt;/literal&gt;” value is empty, only names of upstreams will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, HTTPUpstream>> GetHttpUpstreamsAsync(string fields)
        {
            return GetHttpUpstreamsAsync(fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return status of all HTTP upstream server groups</summary>
        /// <param name="fields">Limits which fields of upstream server groups will be output. If the “&lt;literal&gt;fields&lt;/literal&gt;” value is empty, only names of upstreams will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, HTTPUpstream>> GetHttpUpstreamsAsync(string fields, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/http/upstreams/?");
            if (fields != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(fields, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.IDictionary<string, HTTPUpstream>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(System.Collections.Generic.IDictionary<string, HTTPUpstream>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Return status of an HTTP upstream server group</summary>
        /// <param name="fields">Limits which fields of the upstream server group will be output.</param>
        /// <param name="httpUpstreamName">The name of an HTTP upstream server group.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<HTTPUpstream> GetHttpUpstreamNameAsync(string fields, string httpUpstreamName)
        {
            return GetHttpUpstreamNameAsync(fields, httpUpstreamName, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return status of an HTTP upstream server group</summary>
        /// <param name="fields">Limits which fields of the upstream server group will be output.</param>
        /// <param name="httpUpstreamName">The name of an HTTP upstream server group.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<HTTPUpstream> GetHttpUpstreamNameAsync(string fields, string httpUpstreamName, System.Threading.CancellationToken cancellationToken)
        {
            if (httpUpstreamName == null)
                throw new System.ArgumentNullException("httpUpstreamName");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/http/upstreams/{httpUpstreamName}/?");
            urlBuilder_.Replace("{httpUpstreamName}", System.Uri.EscapeDataString(ConvertToString(httpUpstreamName, System.Globalization.CultureInfo.InvariantCulture)));
            if (fields != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(fields, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<HTTPUpstream>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Upstream is static (*UpstreamStatic*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Upstream not found (*UpstreamNotFound*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(HTTPUpstream);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Reset statistics of an HTTP upstream server group</summary>
        /// <param name="httpUpstreamName">The name of an HTTP upstream server group.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteHttpUpstreamStatAsync(string httpUpstreamName)
        {
            return DeleteHttpUpstreamStatAsync(httpUpstreamName, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Reset statistics of an HTTP upstream server group</summary>
        /// <param name="httpUpstreamName">The name of an HTTP upstream server group.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteHttpUpstreamStatAsync(string httpUpstreamName, System.Threading.CancellationToken cancellationToken)
        {
            if (httpUpstreamName == null)
                throw new System.ArgumentNullException("httpUpstreamName");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/http/upstreams/{httpUpstreamName}/");
            urlBuilder_.Replace("{httpUpstreamName}", System.Uri.EscapeDataString(ConvertToString(httpUpstreamName, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204") 
                        {
                            return;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Upstream is static (*UpstreamStatic*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Upstream not found (*UpstreamNotFound*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Method disabled (*MethodDisabled*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Return configuration of all servers in an HTTP upstream server group</summary>
        /// <param name="httpUpstreamName">The name of an upstream server group.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<HTTPUpstreamConfServer>> GetHttpUpstreamServersAsync(string httpUpstreamName)
        {
            return GetHttpUpstreamServersAsync(httpUpstreamName, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return configuration of all servers in an HTTP upstream server group</summary>
        /// <param name="httpUpstreamName">The name of an upstream server group.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<HTTPUpstreamConfServer>> GetHttpUpstreamServersAsync(string httpUpstreamName, System.Threading.CancellationToken cancellationToken)
        {
            if (httpUpstreamName == null)
                throw new System.ArgumentNullException("httpUpstreamName");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/http/upstreams/{httpUpstreamName}/servers/");
            urlBuilder_.Replace("{httpUpstreamName}", System.Uri.EscapeDataString(ConvertToString(httpUpstreamName, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<HTTPUpstreamConfServer>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Upstream is static (*UpstreamStatic*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Upstream not found (*UpstreamNotFound*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(System.Collections.Generic.ICollection<HTTPUpstreamConfServer>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Add a server to an HTTP upstream server group</summary>
        /// <param name="postHttpUpstreamServer">Address of a new server and other optional parameters in the JSON format. The “*ID*”, “*backup*”, and “*service*” parameters cannot be changed.</param>
        /// <param name="httpUpstreamName">The name of an upstream server group.</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<HTTPUpstreamConfServer> PostHttpUpstreamServerAsync(HTTPUpstreamConfServer postHttpUpstreamServer, string httpUpstreamName)
        {
            return PostHttpUpstreamServerAsync(postHttpUpstreamServer, httpUpstreamName, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Add a server to an HTTP upstream server group</summary>
        /// <param name="postHttpUpstreamServer">Address of a new server and other optional parameters in the JSON format. The “*ID*”, “*backup*”, and “*service*” parameters cannot be changed.</param>
        /// <param name="httpUpstreamName">The name of an upstream server group.</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<HTTPUpstreamConfServer> PostHttpUpstreamServerAsync(HTTPUpstreamConfServer postHttpUpstreamServer, string httpUpstreamName, System.Threading.CancellationToken cancellationToken)
        {
            if (httpUpstreamName == null)
                throw new System.ArgumentNullException("httpUpstreamName");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/http/upstreams/{httpUpstreamName}/servers/");
            urlBuilder_.Replace("{httpUpstreamName}", System.Uri.EscapeDataString(ConvertToString(httpUpstreamName, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(postHttpUpstreamServer, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<HTTPUpstreamConfServer>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Upstream is static (*UpstreamStatic*),\ninvalid \u201c**parameter**\u201d value (*UpstreamConfFormatError*),\nmissing \u201c*server*\u201d argument (*UpstreamConfFormatError*),\nunknown parameter \u201c**name**\u201d (*UpstreamConfFormatError*),\nnested object or list (*UpstreamConfFormatError*),\n\u201c*error*\u201d while parsing (*UpstreamBadAddress*),\nservice upstream \u201c*host*\u201d may not have port (*UpstreamBadAddress*),\nservice upstream \u201c*host*\u201d requires domain name (*UpstreamBadAddress*),\ninvalid \u201c*weight*\u201d (*UpstreamBadWeight*),\ninvalid \u201c*max_conns*\u201d (*UpstreamBadMaxConns*),\ninvalid \u201c*max_fails*\u201d (*UpstreamBadMaxFails*),\ninvalid \u201c*fail_timeout*\u201d (*UpstreamBadFailTimeout*),\ninvalid \u201c*slow_start*\u201d (*UpstreamBadSlowStart*),\nroute is too long (*UpstreamBadRoute*),\n\u201c*service*\u201d is empty (*UpstreamBadService*),\nno resolver defined to resolve (*UpstreamConfNoResolver*),\nupstream \u201c**name**\u201d has no backup (*UpstreamNoBackup*),\nupstream \u201c**name**\u201d memory exhausted (*UpstreamOutOfMemory*)\n", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Upstream not found (*UpstreamNotFound*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Method disabled (*MethodDisabled*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "415") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("JSON error (*JsonError*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(HTTPUpstreamConfServer);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Return configuration of a server in an HTTP upstream server group</summary>
        /// <param name="httpUpstreamName">The name of the upstream server group.</param>
        /// <param name="httpUpstreamServerId">The ID of the server.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<HTTPUpstreamConfServer> GetHttpUpstreamPeerAsync(string httpUpstreamName, string httpUpstreamServerId)
        {
            return GetHttpUpstreamPeerAsync(httpUpstreamName, httpUpstreamServerId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return configuration of a server in an HTTP upstream server group</summary>
        /// <param name="httpUpstreamName">The name of the upstream server group.</param>
        /// <param name="httpUpstreamServerId">The ID of the server.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<HTTPUpstreamConfServer> GetHttpUpstreamPeerAsync(string httpUpstreamName, string httpUpstreamServerId, System.Threading.CancellationToken cancellationToken)
        {
            if (httpUpstreamName == null)
                throw new System.ArgumentNullException("httpUpstreamName");
    
            if (httpUpstreamServerId == null)
                throw new System.ArgumentNullException("httpUpstreamServerId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/http/upstreams/{httpUpstreamName}/servers/{httpUpstreamServerId}");
            urlBuilder_.Replace("{httpUpstreamName}", System.Uri.EscapeDataString(ConvertToString(httpUpstreamName, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{httpUpstreamServerId}", System.Uri.EscapeDataString(ConvertToString(httpUpstreamServerId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<HTTPUpstreamConfServer>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Upstream is static (*UpstreamStatic*),\ninvalid server ID (*UpstreamBadServerId*)\n", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Upstream not found (*UpstreamNotFound*),\nserver with ID \u201c**id**\u201d does not exist (*UpstreamServerNotFound*)\n", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(HTTPUpstreamConfServer);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Modify a server in an HTTP upstream server group</summary>
        /// <param name="patchHttpUpstreamServer">Server parameters, specified in the JSON format. The “*ID*”, “*backup*”, and “*service*” parameters cannot be changed.</param>
        /// <param name="httpUpstreamName">The name of the upstream server group.</param>
        /// <param name="httpUpstreamServerId">The ID of the server.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<HTTPUpstreamConfServer> PatchHttpUpstreamPeerAsync(HTTPUpstreamConfServer patchHttpUpstreamServer, string httpUpstreamName, string httpUpstreamServerId)
        {
            return PatchHttpUpstreamPeerAsync(patchHttpUpstreamServer, httpUpstreamName, httpUpstreamServerId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Modify a server in an HTTP upstream server group</summary>
        /// <param name="patchHttpUpstreamServer">Server parameters, specified in the JSON format. The “*ID*”, “*backup*”, and “*service*” parameters cannot be changed.</param>
        /// <param name="httpUpstreamName">The name of the upstream server group.</param>
        /// <param name="httpUpstreamServerId">The ID of the server.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<HTTPUpstreamConfServer> PatchHttpUpstreamPeerAsync(HTTPUpstreamConfServer patchHttpUpstreamServer, string httpUpstreamName, string httpUpstreamServerId, System.Threading.CancellationToken cancellationToken)
        {
            if (httpUpstreamName == null)
                throw new System.ArgumentNullException("httpUpstreamName");
    
            if (httpUpstreamServerId == null)
                throw new System.ArgumentNullException("httpUpstreamServerId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/http/upstreams/{httpUpstreamName}/servers/{httpUpstreamServerId}");
            urlBuilder_.Replace("{httpUpstreamName}", System.Uri.EscapeDataString(ConvertToString(httpUpstreamName, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{httpUpstreamServerId}", System.Uri.EscapeDataString(ConvertToString(httpUpstreamServerId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(patchHttpUpstreamServer, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PATCH");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<HTTPUpstreamConfServer>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Upstream is static (*UpstreamStatic*),\ninvalid \u201c**parameter**\u201d value (*UpstreamConfFormatError*),\nunknown parameter \u201c**name**\u201d (*UpstreamConfFormatError*),\nnested object or list (*UpstreamConfFormatError*),\n\u201c*error*\u201d while parsing (*UpstreamBadAddress*),\ninvalid \u201c*server*\u201d argument (*UpstreamBadAddress*),\ninvalid server ID (*UpstreamBadServerId*),\ninvalid \u201c*weight*\u201d (*UpstreamBadWeight*),\ninvalid \u201c*max_conns*\u201d (*UpstreamBadMaxConns*),\ninvalid \u201c*max_fails*\u201d (*UpstreamBadMaxFails*),\ninvalid \u201c*fail_timeout*\u201d (*UpstreamBadFailTimeout*),\ninvalid \u201c*slow_start*\u201d (*UpstreamBadSlowStart*),\nroute is too long (*UpstreamBadRoute*),\n\u201c*service*\u201d is empty (*UpstreamBadService*),\nserver \u201c**ID**\u201d address is immutable (*UpstreamServerImmutable*),\nserver \u201c*ID*\u201d weight is immutable (*UpstreamServerWeightImmutable*),\nupstream \u201c*name*\u201d memory exhausted (*UpstreamOutOfMemory*)\n", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Upstream not found (*UpstreamNotFound*),\nserver with ID \u201c**id**\u201d does not exist (*UpstreamServerNotFound*)\n", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Method disabled (*MethodDisabled*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "415") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("JSON error (*JsonError*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(HTTPUpstreamConfServer);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Remove a server from an HTTP upstream server group</summary>
        /// <param name="httpUpstreamName">The name of the upstream server group.</param>
        /// <param name="httpUpstreamServerId">The ID of the server.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<HTTPUpstreamConfServer>> DeleteHttpUpstreamServerAsync(string httpUpstreamName, string httpUpstreamServerId)
        {
            return DeleteHttpUpstreamServerAsync(httpUpstreamName, httpUpstreamServerId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Remove a server from an HTTP upstream server group</summary>
        /// <param name="httpUpstreamName">The name of the upstream server group.</param>
        /// <param name="httpUpstreamServerId">The ID of the server.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<HTTPUpstreamConfServer>> DeleteHttpUpstreamServerAsync(string httpUpstreamName, string httpUpstreamServerId, System.Threading.CancellationToken cancellationToken)
        {
            if (httpUpstreamName == null)
                throw new System.ArgumentNullException("httpUpstreamName");
    
            if (httpUpstreamServerId == null)
                throw new System.ArgumentNullException("httpUpstreamServerId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/http/upstreams/{httpUpstreamName}/servers/{httpUpstreamServerId}");
            urlBuilder_.Replace("{httpUpstreamName}", System.Uri.EscapeDataString(ConvertToString(httpUpstreamName, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{httpUpstreamServerId}", System.Uri.EscapeDataString(ConvertToString(httpUpstreamServerId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<HTTPUpstreamConfServer>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Upstream is static (*UpstreamStatic*),\ninvalid server ID (*UpstreamBadServerId*),\nserver \u201c**id**\u201d not removable (*UpstreamServerImmutable*)\n", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Upstream not found (*UpstreamNotFound*),\nserver with ID \u201c**id**\u201d does not exist (*UpstreamServerNotFound*)\n", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Method disabled (*MethodDisabled*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(System.Collections.Generic.ICollection<HTTPUpstreamConfServer>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Return key-value pairs from all HTTP keyval zones</summary>
        /// <param name="fields">If the “&lt;literal&gt;fields&lt;/literal&gt;” value is empty, then only HTTP keyval zone names will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, HTTPKeyvalZone>> GetHttpKeyvalZonesAsync(string fields)
        {
            return GetHttpKeyvalZonesAsync(fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return key-value pairs from all HTTP keyval zones</summary>
        /// <param name="fields">If the “&lt;literal&gt;fields&lt;/literal&gt;” value is empty, then only HTTP keyval zone names will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, HTTPKeyvalZone>> GetHttpKeyvalZonesAsync(string fields, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/http/keyvals/?");
            if (fields != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(fields, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.IDictionary<string, HTTPKeyvalZone>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(System.Collections.Generic.IDictionary<string, HTTPKeyvalZone>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Return key-value pairs from an HTTP keyval zone</summary>
        /// <param name="key">Get a particular key-value pair from the HTTP keyval zone.</param>
        /// <param name="httpKeyvalZoneName">The name of an HTTP keyval shared memory zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<HTTPKeyvalZone> GetHttpKeyvalZoneKeysValuesAsync(string key, string httpKeyvalZoneName)
        {
            return GetHttpKeyvalZoneKeysValuesAsync(key, httpKeyvalZoneName, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return key-value pairs from an HTTP keyval zone</summary>
        /// <param name="key">Get a particular key-value pair from the HTTP keyval zone.</param>
        /// <param name="httpKeyvalZoneName">The name of an HTTP keyval shared memory zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<HTTPKeyvalZone> GetHttpKeyvalZoneKeysValuesAsync(string key, string httpKeyvalZoneName, System.Threading.CancellationToken cancellationToken)
        {
            if (httpKeyvalZoneName == null)
                throw new System.ArgumentNullException("httpKeyvalZoneName");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/http/keyvals/{httpKeyvalZoneName}?");
            urlBuilder_.Replace("{httpKeyvalZoneName}", System.Uri.EscapeDataString(ConvertToString(httpKeyvalZoneName, System.Globalization.CultureInfo.InvariantCulture)));
            if (key != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("key") + "=").Append(System.Uri.EscapeDataString(ConvertToString(key, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<HTTPKeyvalZone>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "404") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Keyval not found (*KeyvalNotFound*),\nkeyval key not found (*KeyvalKeyNotFound*)\n", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(HTTPKeyvalZone);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Add a key-value pair to the HTTP keyval zone</summary>
        /// <param name="key_value">A key-value pair is specified in the JSON format. Several key-value pairs can be entered if the HTTP keyval shared memory zone is empty. Expiration time in milliseconds can be specified for a key-value pair with the *expire* parameter which overrides the [*timeout*](https://nginx.org/en/docs/http/ngx_http_keyval_module.html#keyval_timeout) parameter of the &lt;a href="https://nginx.org/en/docs/http/ngx_http_keyval_module.html#keyval_zone"&gt;keyval_zone&lt;/a&gt; directive.</param>
        /// <param name="httpKeyvalZoneName">The name of an HTTP keyval shared memory zone.</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task PostHttpKeyvalZoneDataAsync(HTTPKeyvalZonePostPatch key_value, string httpKeyvalZoneName)
        {
            return PostHttpKeyvalZoneDataAsync(key_value, httpKeyvalZoneName, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Add a key-value pair to the HTTP keyval zone</summary>
        /// <param name="key_value">A key-value pair is specified in the JSON format. Several key-value pairs can be entered if the HTTP keyval shared memory zone is empty. Expiration time in milliseconds can be specified for a key-value pair with the *expire* parameter which overrides the [*timeout*](https://nginx.org/en/docs/http/ngx_http_keyval_module.html#keyval_timeout) parameter of the &lt;a href="https://nginx.org/en/docs/http/ngx_http_keyval_module.html#keyval_zone"&gt;keyval_zone&lt;/a&gt; directive.</param>
        /// <param name="httpKeyvalZoneName">The name of an HTTP keyval shared memory zone.</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task PostHttpKeyvalZoneDataAsync(HTTPKeyvalZonePostPatch key_value, string httpKeyvalZoneName, System.Threading.CancellationToken cancellationToken)
        {
            if (httpKeyvalZoneName == null)
                throw new System.ArgumentNullException("httpKeyvalZoneName");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/http/keyvals/{httpKeyvalZoneName}");
            urlBuilder_.Replace("{httpKeyvalZoneName}", System.Uri.EscapeDataString(ConvertToString(httpKeyvalZoneName, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(key_value, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201") 
                        {
                            return;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Invalid JSON (*KeyvalFormatError*),\ninvalid key format (*KeyvalFormatError*),\nkey required (*KeyvalFormatError*),\nkeyval timeout is not enabled (*KeyvalFormatError*),\nonly one key can be added (*KeyvalFormatError*)\n", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Keyval not found (*KeyvalNotFound*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Method disabled (*MethodDisabled*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "409") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Key already exists (*KeyvalKeyExists*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "415") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("JSON error (*JsonError*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Modify a key-value or delete a key</summary>
        /// <param name="httpKeyvalZoneKeyValue">A new value for the key is specified in the JSON format.</param>
        /// <param name="httpKeyvalZoneName">The name of an HTTP keyval shared memory zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task PatchHttpKeyvalZoneKeyValueAsync(HTTPKeyvalZonePostPatch httpKeyvalZoneKeyValue, string httpKeyvalZoneName)
        {
            return PatchHttpKeyvalZoneKeyValueAsync(httpKeyvalZoneKeyValue, httpKeyvalZoneName, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Modify a key-value or delete a key</summary>
        /// <param name="httpKeyvalZoneKeyValue">A new value for the key is specified in the JSON format.</param>
        /// <param name="httpKeyvalZoneName">The name of an HTTP keyval shared memory zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task PatchHttpKeyvalZoneKeyValueAsync(HTTPKeyvalZonePostPatch httpKeyvalZoneKeyValue, string httpKeyvalZoneName, System.Threading.CancellationToken cancellationToken)
        {
            if (httpKeyvalZoneName == null)
                throw new System.ArgumentNullException("httpKeyvalZoneName");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/http/keyvals/{httpKeyvalZoneName}");
            urlBuilder_.Replace("{httpKeyvalZoneName}", System.Uri.EscapeDataString(ConvertToString(httpKeyvalZoneName, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(httpKeyvalZoneKeyValue, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PATCH");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204") 
                        {
                            return;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Invalid JSON (*KeyvalFormatError*),\nkey required (*KeyvalFormatError*),\nkeyval timeout is not enabled (*KeyvalFormatError*),\nonly one key can be updated (*KeyvalFormatError*)\n", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Keyval not found (*KeyvalNotFound*),\nkeyval key not found (*KeyvalKeyNotFound*)\n", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Method disabled (*MethodDisabled*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "415") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("JSON error (*JsonError*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Empty the HTTP keyval zone</summary>
        /// <param name="httpKeyvalZoneName">The name of an HTTP keyval shared memory zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteHttpKeyvalZoneDataAsync(string httpKeyvalZoneName)
        {
            return DeleteHttpKeyvalZoneDataAsync(httpKeyvalZoneName, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Empty the HTTP keyval zone</summary>
        /// <param name="httpKeyvalZoneName">The name of an HTTP keyval shared memory zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteHttpKeyvalZoneDataAsync(string httpKeyvalZoneName, System.Threading.CancellationToken cancellationToken)
        {
            if (httpKeyvalZoneName == null)
                throw new System.ArgumentNullException("httpKeyvalZoneName");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/http/keyvals/{httpKeyvalZoneName}");
            urlBuilder_.Replace("{httpKeyvalZoneName}", System.Uri.EscapeDataString(ConvertToString(httpKeyvalZoneName, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204") 
                        {
                            return;
                        }
                        else
                        if (status_ == "404") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Keyval not found (*KeyvalNotFound*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Method disabled (*MethodDisabled*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Return list of stream-related endpoints</summary>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetStreamAsync()
        {
            return GetStreamAsync(System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return list of stream-related endpoints</summary>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetStreamAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/stream/");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<string>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(System.Collections.Generic.ICollection<string>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Return status of all stream server zones</summary>
        /// <param name="fields">Limits which fields of server zones will be output. If the “&lt;literal&gt;fields&lt;/literal&gt;” value is empty, then only server zone names will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, StreamServerZone>> GetStreamServerZonesAsync(string fields)
        {
            return GetStreamServerZonesAsync(fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return status of all stream server zones</summary>
        /// <param name="fields">Limits which fields of server zones will be output. If the “&lt;literal&gt;fields&lt;/literal&gt;” value is empty, then only server zone names will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, StreamServerZone>> GetStreamServerZonesAsync(string fields, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/stream/server_zones/?");
            if (fields != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(fields, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.IDictionary<string, StreamServerZone>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(System.Collections.Generic.IDictionary<string, StreamServerZone>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Return status of a stream server zone</summary>
        /// <param name="fields">Limits which fields of the server zone will be output.</param>
        /// <param name="streamServerZoneName">The name of a stream server zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<StreamServerZone> GetStreamServerZoneAsync(string fields, string streamServerZoneName)
        {
            return GetStreamServerZoneAsync(fields, streamServerZoneName, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return status of a stream server zone</summary>
        /// <param name="fields">Limits which fields of the server zone will be output.</param>
        /// <param name="streamServerZoneName">The name of a stream server zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<StreamServerZone> GetStreamServerZoneAsync(string fields, string streamServerZoneName, System.Threading.CancellationToken cancellationToken)
        {
            if (streamServerZoneName == null)
                throw new System.ArgumentNullException("streamServerZoneName");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/stream/server_zones/{streamServerZoneName}?");
            urlBuilder_.Replace("{streamServerZoneName}", System.Uri.EscapeDataString(ConvertToString(streamServerZoneName, System.Globalization.CultureInfo.InvariantCulture)));
            if (fields != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(fields, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<StreamServerZone>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "404") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Server zone not found (*ServerZoneNotFound*)\n", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(StreamServerZone);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Reset statistics for a stream server zone</summary>
        /// <param name="streamServerZoneName">The name of a stream server zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteStreamServerZoneStatAsync(string streamServerZoneName)
        {
            return DeleteStreamServerZoneStatAsync(streamServerZoneName, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Reset statistics for a stream server zone</summary>
        /// <param name="streamServerZoneName">The name of a stream server zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteStreamServerZoneStatAsync(string streamServerZoneName, System.Threading.CancellationToken cancellationToken)
        {
            if (streamServerZoneName == null)
                throw new System.ArgumentNullException("streamServerZoneName");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/stream/server_zones/{streamServerZoneName}");
            urlBuilder_.Replace("{streamServerZoneName}", System.Uri.EscapeDataString(ConvertToString(streamServerZoneName, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204") 
                        {
                            return;
                        }
                        else
                        if (status_ == "404") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Server zone not found (*ServerZoneNotFound*)\n", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Method disabled (*MethodDisabled*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Return status of all stream limit_conn zones</summary>
        /// <param name="fields">Limits which fields of limit_conn zones will be output. If the “&lt;literal&gt;fields&lt;/literal&gt;” value is empty, then only zone names will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, StreamLimitConnZone>> GetStreamLimitConnZonesAsync(string fields)
        {
            return GetStreamLimitConnZonesAsync(fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return status of all stream limit_conn zones</summary>
        /// <param name="fields">Limits which fields of limit_conn zones will be output. If the “&lt;literal&gt;fields&lt;/literal&gt;” value is empty, then only zone names will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, StreamLimitConnZone>> GetStreamLimitConnZonesAsync(string fields, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/stream/limit_conns/?");
            if (fields != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(fields, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.IDictionary<string, StreamLimitConnZone>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(System.Collections.Generic.IDictionary<string, StreamLimitConnZone>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Return status of an stream limit_conn zone</summary>
        /// <param name="fields">Limits which fields of the [limit_conn zone](https://nginx.org/en/docs/stream/ngx_stream_limit_conn_module.html#limit_conn_zone) will be output.</param>
        /// <param name="streamLimitConnZoneName">The name of a [limit_conn zone](https://nginx.org/en/docs/stream/ngx_stream_limit_conn_module.html#limit_conn_zone).</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<StreamLimitConnZone> GetStreamLimitConnZoneAsync(string fields, string streamLimitConnZoneName)
        {
            return GetStreamLimitConnZoneAsync(fields, streamLimitConnZoneName, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return status of an stream limit_conn zone</summary>
        /// <param name="fields">Limits which fields of the [limit_conn zone](https://nginx.org/en/docs/stream/ngx_stream_limit_conn_module.html#limit_conn_zone) will be output.</param>
        /// <param name="streamLimitConnZoneName">The name of a [limit_conn zone](https://nginx.org/en/docs/stream/ngx_stream_limit_conn_module.html#limit_conn_zone).</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<StreamLimitConnZone> GetStreamLimitConnZoneAsync(string fields, string streamLimitConnZoneName, System.Threading.CancellationToken cancellationToken)
        {
            if (streamLimitConnZoneName == null)
                throw new System.ArgumentNullException("streamLimitConnZoneName");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/stream/limit_conns/{streamLimitConnZoneName}?");
            urlBuilder_.Replace("{streamLimitConnZoneName}", System.Uri.EscapeDataString(ConvertToString(streamLimitConnZoneName, System.Globalization.CultureInfo.InvariantCulture)));
            if (fields != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(fields, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<StreamLimitConnZone>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "404") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("limit_conn not found (*LimitConnNotFound*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(StreamLimitConnZone);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Reset statistics for a stream limit_conn zone</summary>
        /// <param name="streamLimitConnZoneName">The name of a [limit_conn zone](https://nginx.org/en/docs/stream/ngx_stream_limit_conn_module.html#limit_conn_zone).</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteStreamLimitConnZoneStatAsync(string streamLimitConnZoneName)
        {
            return DeleteStreamLimitConnZoneStatAsync(streamLimitConnZoneName, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Reset statistics for a stream limit_conn zone</summary>
        /// <param name="streamLimitConnZoneName">The name of a [limit_conn zone](https://nginx.org/en/docs/stream/ngx_stream_limit_conn_module.html#limit_conn_zone).</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteStreamLimitConnZoneStatAsync(string streamLimitConnZoneName, System.Threading.CancellationToken cancellationToken)
        {
            if (streamLimitConnZoneName == null)
                throw new System.ArgumentNullException("streamLimitConnZoneName");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/stream/limit_conns/{streamLimitConnZoneName}");
            urlBuilder_.Replace("{streamLimitConnZoneName}", System.Uri.EscapeDataString(ConvertToString(streamLimitConnZoneName, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204") 
                        {
                            return;
                        }
                        else
                        if (status_ == "404") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("limit_conn not found (*LimitConnNotFound*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Method disabled (*MethodDisabled*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Return status of all stream upstream server groups</summary>
        /// <param name="fields">Limits which fields of upstream server groups will be output. If the “&lt;literal&gt;fields&lt;/literal&gt;” value is empty, only names of upstreams will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, StreamUpstream>> GetStreamUpstreamsAsync(string fields)
        {
            return GetStreamUpstreamsAsync(fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return status of all stream upstream server groups</summary>
        /// <param name="fields">Limits which fields of upstream server groups will be output. If the “&lt;literal&gt;fields&lt;/literal&gt;” value is empty, only names of upstreams will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, StreamUpstream>> GetStreamUpstreamsAsync(string fields, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/stream/upstreams/?");
            if (fields != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(fields, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.IDictionary<string, StreamUpstream>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(System.Collections.Generic.IDictionary<string, StreamUpstream>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Return status of a stream upstream server group</summary>
        /// <param name="fields">Limits which fields of the upstream server group will be output.</param>
        /// <param name="streamUpstreamName">The name of a stream upstream server group.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<StreamUpstream> GetStreamUpstreamAsync(string fields, string streamUpstreamName)
        {
            return GetStreamUpstreamAsync(fields, streamUpstreamName, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return status of a stream upstream server group</summary>
        /// <param name="fields">Limits which fields of the upstream server group will be output.</param>
        /// <param name="streamUpstreamName">The name of a stream upstream server group.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<StreamUpstream> GetStreamUpstreamAsync(string fields, string streamUpstreamName, System.Threading.CancellationToken cancellationToken)
        {
            if (streamUpstreamName == null)
                throw new System.ArgumentNullException("streamUpstreamName");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/stream/upstreams/{streamUpstreamName}/?");
            urlBuilder_.Replace("{streamUpstreamName}", System.Uri.EscapeDataString(ConvertToString(streamUpstreamName, System.Globalization.CultureInfo.InvariantCulture)));
            if (fields != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(fields, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<StreamUpstream>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Upstream is static (*UpstreamStatic*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Upstream not found (*UpstreamNotFound*)\n", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(StreamUpstream);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Reset statistics of a stream upstream server group</summary>
        /// <param name="streamUpstreamName">The name of a stream upstream server group.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteStreamUpstreamStatAsync(string streamUpstreamName)
        {
            return DeleteStreamUpstreamStatAsync(streamUpstreamName, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Reset statistics of a stream upstream server group</summary>
        /// <param name="streamUpstreamName">The name of a stream upstream server group.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteStreamUpstreamStatAsync(string streamUpstreamName, System.Threading.CancellationToken cancellationToken)
        {
            if (streamUpstreamName == null)
                throw new System.ArgumentNullException("streamUpstreamName");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/stream/upstreams/{streamUpstreamName}/");
            urlBuilder_.Replace("{streamUpstreamName}", System.Uri.EscapeDataString(ConvertToString(streamUpstreamName, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204") 
                        {
                            return;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Upstream is static (*UpstreamStatic*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Upstream not found (*UpstreamNotFound*)\n", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Method disabled (*MethodDisabled*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Return configuration of all servers in a stream upstream server group</summary>
        /// <param name="streamUpstreamName">The name of an upstream server group.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<StreamUpstreamConfServer>> GetStreamUpstreamServersAsync(string streamUpstreamName)
        {
            return GetStreamUpstreamServersAsync(streamUpstreamName, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return configuration of all servers in a stream upstream server group</summary>
        /// <param name="streamUpstreamName">The name of an upstream server group.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<StreamUpstreamConfServer>> GetStreamUpstreamServersAsync(string streamUpstreamName, System.Threading.CancellationToken cancellationToken)
        {
            if (streamUpstreamName == null)
                throw new System.ArgumentNullException("streamUpstreamName");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/stream/upstreams/{streamUpstreamName}/servers/");
            urlBuilder_.Replace("{streamUpstreamName}", System.Uri.EscapeDataString(ConvertToString(streamUpstreamName, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<StreamUpstreamConfServer>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Upstream is static (*UpstreamStatic*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Upstream not found (*UpstreamNotFound*)\n", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(System.Collections.Generic.ICollection<StreamUpstreamConfServer>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Add a server to a stream upstream server group</summary>
        /// <param name="postStreamUpstreamServer">Address of a new server and other optional parameters in the JSON format. The “*ID*”, “*backup*”, and “*service*” parameters cannot be changed.</param>
        /// <param name="streamUpstreamName">The name of an upstream server group.</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<StreamUpstreamConfServer> PostStreamUpstreamServerAsync(StreamUpstreamConfServer postStreamUpstreamServer, string streamUpstreamName)
        {
            return PostStreamUpstreamServerAsync(postStreamUpstreamServer, streamUpstreamName, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Add a server to a stream upstream server group</summary>
        /// <param name="postStreamUpstreamServer">Address of a new server and other optional parameters in the JSON format. The “*ID*”, “*backup*”, and “*service*” parameters cannot be changed.</param>
        /// <param name="streamUpstreamName">The name of an upstream server group.</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<StreamUpstreamConfServer> PostStreamUpstreamServerAsync(StreamUpstreamConfServer postStreamUpstreamServer, string streamUpstreamName, System.Threading.CancellationToken cancellationToken)
        {
            if (streamUpstreamName == null)
                throw new System.ArgumentNullException("streamUpstreamName");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/stream/upstreams/{streamUpstreamName}/servers/");
            urlBuilder_.Replace("{streamUpstreamName}", System.Uri.EscapeDataString(ConvertToString(streamUpstreamName, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(postStreamUpstreamServer, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<StreamUpstreamConfServer>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Upstream is static (*UpstreamStatic*),\ninvalid \u201c**parameter**\u201d value (*UpstreamConfFormatError*),\nmissing \u201c*server*\u201d argument (*UpstreamConfFormatError*),\nunknown parameter \u201c**name**\u201d (*UpstreamConfFormatError*),\nnested object or list (*UpstreamConfFormatError*),\n\u201c*error*\u201d while parsing (*UpstreamBadAddress*),\nno port in server \u201c*host*\u201d (*UpstreamBadAddress*),\nservice upstream \u201c*host*\u201d may not have port (*UpstreamBadAddress*),\nservice upstream \u201c*host*\u201d requires domain name (*UpstreamBadAddress*),\ninvalid \u201c*weight*\u201d (*UpstreamBadWeight*),\ninvalid \u201c*max_conns*\u201d (*UpstreamBadMaxConns*),\ninvalid \u201c*max_fails*\u201d (*UpstreamBadMaxFails*),\ninvalid \u201c*fail_timeout*\u201d (*UpstreamBadFailTimeout*),\ninvalid \u201c*slow_start*\u201d (*UpstreamBadSlowStart*),\n\u201c*service*\u201d is empty (*UpstreamBadService*),\nno resolver defined to resolve (*UpstreamConfNoResolver*),\nupstream \u201c**name**\u201d has no backup (*UpstreamNoBackup*),\nupstream \u201c**name**\u201d memory exhausted (*UpstreamOutOfMemory*)\n", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Upstream not found (*UpstreamNotFound*)\n", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Method disabled (*MethodDisabled*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "415") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("JSON error (*JsonError*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(StreamUpstreamConfServer);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Return configuration of a server in a stream upstream server group</summary>
        /// <param name="streamUpstreamName">The name of the upstream server group.</param>
        /// <param name="streamUpstreamServerId">The ID of the server.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<StreamUpstreamConfServer> GetStreamUpstreamServerAsync(string streamUpstreamName, string streamUpstreamServerId)
        {
            return GetStreamUpstreamServerAsync(streamUpstreamName, streamUpstreamServerId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return configuration of a server in a stream upstream server group</summary>
        /// <param name="streamUpstreamName">The name of the upstream server group.</param>
        /// <param name="streamUpstreamServerId">The ID of the server.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<StreamUpstreamConfServer> GetStreamUpstreamServerAsync(string streamUpstreamName, string streamUpstreamServerId, System.Threading.CancellationToken cancellationToken)
        {
            if (streamUpstreamName == null)
                throw new System.ArgumentNullException("streamUpstreamName");
    
            if (streamUpstreamServerId == null)
                throw new System.ArgumentNullException("streamUpstreamServerId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/stream/upstreams/{streamUpstreamName}/servers/{streamUpstreamServerId}");
            urlBuilder_.Replace("{streamUpstreamName}", System.Uri.EscapeDataString(ConvertToString(streamUpstreamName, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{streamUpstreamServerId}", System.Uri.EscapeDataString(ConvertToString(streamUpstreamServerId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<StreamUpstreamConfServer>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Upstream is static (*UpstreamStatic*),\ninvalid server ID (*UpstreamBadServerId*)\n", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Upstream not found (*UpstreamNotFound*),\nserver with ID \u201c**id**\u201d does not exist (*UpstreamServerNotFound*)\n", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(StreamUpstreamConfServer);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Modify a server in a stream upstream server group</summary>
        /// <param name="patchStreamUpstreamServer">Server parameters, specified in the JSON format. The “*ID*”, “*backup*”, and “*service*” parameters cannot be changed.</param>
        /// <param name="streamUpstreamName">The name of the upstream server group.</param>
        /// <param name="streamUpstreamServerId">The ID of the server.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<StreamUpstreamConfServer> PatchStreamUpstreamServerAsync(StreamUpstreamConfServer patchStreamUpstreamServer, string streamUpstreamName, string streamUpstreamServerId)
        {
            return PatchStreamUpstreamServerAsync(patchStreamUpstreamServer, streamUpstreamName, streamUpstreamServerId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Modify a server in a stream upstream server group</summary>
        /// <param name="patchStreamUpstreamServer">Server parameters, specified in the JSON format. The “*ID*”, “*backup*”, and “*service*” parameters cannot be changed.</param>
        /// <param name="streamUpstreamName">The name of the upstream server group.</param>
        /// <param name="streamUpstreamServerId">The ID of the server.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<StreamUpstreamConfServer> PatchStreamUpstreamServerAsync(StreamUpstreamConfServer patchStreamUpstreamServer, string streamUpstreamName, string streamUpstreamServerId, System.Threading.CancellationToken cancellationToken)
        {
            if (streamUpstreamName == null)
                throw new System.ArgumentNullException("streamUpstreamName");
    
            if (streamUpstreamServerId == null)
                throw new System.ArgumentNullException("streamUpstreamServerId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/stream/upstreams/{streamUpstreamName}/servers/{streamUpstreamServerId}");
            urlBuilder_.Replace("{streamUpstreamName}", System.Uri.EscapeDataString(ConvertToString(streamUpstreamName, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{streamUpstreamServerId}", System.Uri.EscapeDataString(ConvertToString(streamUpstreamServerId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(patchStreamUpstreamServer, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PATCH");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<StreamUpstreamConfServer>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Upstream is static (*UpstreamStatic*),\ninvalid \u201c**parameter**\u201d value (*UpstreamConfFormatError*),\nunknown parameter \u201c**name**\u201d (*UpstreamConfFormatError*),\nnested object or list (*UpstreamConfFormatError*),\n\u201c*error*\u201d while parsing (*UpstreamBadAddress*),\ninvalid \u201c*server*\u201d argument (*UpstreamBadAddress*),\nno port in server \u201c*host*\u201d (*UpstreamBadAddress*),\ninvalid server ID (*UpstreamBadServerId*),\ninvalid \u201c*weight*\u201d (*UpstreamBadWeight*),\ninvalid \u201c*max_conns*\u201d (*UpstreamBadMaxConns*),\ninvalid \u201c*max_fails*\u201d (*UpstreamBadMaxFails*),\ninvalid \u201c*fail_timeout*\u201d (*UpstreamBadFailTimeout*),\ninvalid \u201c*slow_start*\u201d (*UpstreamBadSlowStart*),\n\u201c*service*\u201d is empty (*UpstreamBadService*),\nserver \u201c**ID**\u201d address is immutable (*UpstreamServerImmutable*),\nserver \u201c**ID**\u201d weight is immutable (*UpstreamServerWeightImmutable*),\nupstream \u201c*name*\u201d memory exhausted (*UpstreamOutOfMemory*)\n", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Upstream not found (*UpstreamNotFound*),\nserver with ID \u201c**id**\u201d does not exist (*UpstreamServerNotFound*)\n", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Method disabled (*MethodDisabled*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "415") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("JSON error (*JsonError*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(StreamUpstreamConfServer);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Remove a server from a stream upstream server group</summary>
        /// <param name="streamUpstreamName">The name of the upstream server group.</param>
        /// <param name="streamUpstreamServerId">The ID of the server.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<StreamUpstreamConfServer>> DeleteStreamUpstreamServerAsync(string streamUpstreamName, string streamUpstreamServerId)
        {
            return DeleteStreamUpstreamServerAsync(streamUpstreamName, streamUpstreamServerId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Remove a server from a stream upstream server group</summary>
        /// <param name="streamUpstreamName">The name of the upstream server group.</param>
        /// <param name="streamUpstreamServerId">The ID of the server.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<StreamUpstreamConfServer>> DeleteStreamUpstreamServerAsync(string streamUpstreamName, string streamUpstreamServerId, System.Threading.CancellationToken cancellationToken)
        {
            if (streamUpstreamName == null)
                throw new System.ArgumentNullException("streamUpstreamName");
    
            if (streamUpstreamServerId == null)
                throw new System.ArgumentNullException("streamUpstreamServerId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/stream/upstreams/{streamUpstreamName}/servers/{streamUpstreamServerId}");
            urlBuilder_.Replace("{streamUpstreamName}", System.Uri.EscapeDataString(ConvertToString(streamUpstreamName, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{streamUpstreamServerId}", System.Uri.EscapeDataString(ConvertToString(streamUpstreamServerId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<StreamUpstreamConfServer>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Upstream is static (*UpstreamStatic*),\ninvalid server ID (*UpstreamBadServerId*),\nserver \u201c**id**\u201d not removable (*UpstreamServerImmutable*)\n", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Upstream not found (*UpstreamNotFound*),\nserver with ID \u201c**id**\u201d does not exist (*UpstreamServerNotFound*)\n", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Method disabled (*MethodDisabled*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(System.Collections.Generic.ICollection<StreamUpstreamConfServer>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Return key-value pairs from all stream keyval zones</summary>
        /// <param name="fields">If the “&lt;literal&gt;fields&lt;/literal&gt;” value is empty, then only stream keyval zone names will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, StreamKeyvalZone>> GetStreamKeyvalZonesAsync(string fields)
        {
            return GetStreamKeyvalZonesAsync(fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return key-value pairs from all stream keyval zones</summary>
        /// <param name="fields">If the “&lt;literal&gt;fields&lt;/literal&gt;” value is empty, then only stream keyval zone names will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, StreamKeyvalZone>> GetStreamKeyvalZonesAsync(string fields, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/stream/keyvals/?");
            if (fields != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(fields, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.IDictionary<string, StreamKeyvalZone>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(System.Collections.Generic.IDictionary<string, StreamKeyvalZone>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Return key-value pairs from a stream keyval zone</summary>
        /// <param name="key">Get a particular key-value pair from the stream keyval zone.</param>
        /// <param name="streamKeyvalZoneName">The name of a stream keyval shared memory zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<StreamKeyvalZone> GetStreamKeyvalZoneKeysValuesAsync(string key, string streamKeyvalZoneName)
        {
            return GetStreamKeyvalZoneKeysValuesAsync(key, streamKeyvalZoneName, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return key-value pairs from a stream keyval zone</summary>
        /// <param name="key">Get a particular key-value pair from the stream keyval zone.</param>
        /// <param name="streamKeyvalZoneName">The name of a stream keyval shared memory zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<StreamKeyvalZone> GetStreamKeyvalZoneKeysValuesAsync(string key, string streamKeyvalZoneName, System.Threading.CancellationToken cancellationToken)
        {
            if (streamKeyvalZoneName == null)
                throw new System.ArgumentNullException("streamKeyvalZoneName");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/stream/keyvals/{streamKeyvalZoneName}?");
            urlBuilder_.Replace("{streamKeyvalZoneName}", System.Uri.EscapeDataString(ConvertToString(streamKeyvalZoneName, System.Globalization.CultureInfo.InvariantCulture)));
            if (key != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("key") + "=").Append(System.Uri.EscapeDataString(ConvertToString(key, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<StreamKeyvalZone>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "404") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Keyval not found (*KeyvalNotFound*),\nkeyval key not found (*KeyvalKeyNotFound*)\n", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(StreamKeyvalZone);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Add a key-value pair to the stream keyval zone</summary>
        /// <param name="key_value">A key-value pair is specified in the JSON format. Several key-value pairs can be entered if the stream keyval shared memory zone is empty. Expiration time in milliseconds can be specified for a key-value pair with the *expire* parameter which overrides the [*timeout*](https://nginx.org/en/docs/stream/ngx_stream_keyval_module.html#keyval_timeout) parameter of the &lt;a href="https://nginx.org/en/docs/stream/ngx_stream_keyval_module.html#keyval_zone"&gt;keyval_zone&lt;/a&gt; directive.</param>
        /// <param name="streamKeyvalZoneName">The name of a stream keyval shared memory zone.</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task PostStreamKeyvalZoneDataAsync(StreamKeyvalZonePostPatch key_value, string streamKeyvalZoneName)
        {
            return PostStreamKeyvalZoneDataAsync(key_value, streamKeyvalZoneName, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Add a key-value pair to the stream keyval zone</summary>
        /// <param name="key_value">A key-value pair is specified in the JSON format. Several key-value pairs can be entered if the stream keyval shared memory zone is empty. Expiration time in milliseconds can be specified for a key-value pair with the *expire* parameter which overrides the [*timeout*](https://nginx.org/en/docs/stream/ngx_stream_keyval_module.html#keyval_timeout) parameter of the &lt;a href="https://nginx.org/en/docs/stream/ngx_stream_keyval_module.html#keyval_zone"&gt;keyval_zone&lt;/a&gt; directive.</param>
        /// <param name="streamKeyvalZoneName">The name of a stream keyval shared memory zone.</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task PostStreamKeyvalZoneDataAsync(StreamKeyvalZonePostPatch key_value, string streamKeyvalZoneName, System.Threading.CancellationToken cancellationToken)
        {
            if (streamKeyvalZoneName == null)
                throw new System.ArgumentNullException("streamKeyvalZoneName");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/stream/keyvals/{streamKeyvalZoneName}");
            urlBuilder_.Replace("{streamKeyvalZoneName}", System.Uri.EscapeDataString(ConvertToString(streamKeyvalZoneName, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(key_value, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201") 
                        {
                            return;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Invalid JSON (*KeyvalFormatError*),\ninvalid key format (*KeyvalFormatError*),\nkey required (*KeyvalFormatError*),\nkeyval timeout is not enabled (*KeyvalFormatError*),\nonly one key can be added (*KeyvalFormatError*)\n", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Keyval not found (*KeyvalNotFound*)\n", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Method disabled (*MethodDisabled*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "409") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Key already exists (*KeyvalKeyExists*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "415") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("JSON error (*JsonError*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Modify a key-value or delete a key</summary>
        /// <param name="streamKeyvalZoneKeyValue">A new value for the key is specified in the JSON format.</param>
        /// <param name="streamKeyvalZoneName">The name of a stream keyval shared memory zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task PatchStreamKeyvalZoneKeyValueAsync(StreamKeyvalZonePostPatch streamKeyvalZoneKeyValue, string streamKeyvalZoneName)
        {
            return PatchStreamKeyvalZoneKeyValueAsync(streamKeyvalZoneKeyValue, streamKeyvalZoneName, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Modify a key-value or delete a key</summary>
        /// <param name="streamKeyvalZoneKeyValue">A new value for the key is specified in the JSON format.</param>
        /// <param name="streamKeyvalZoneName">The name of a stream keyval shared memory zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task PatchStreamKeyvalZoneKeyValueAsync(StreamKeyvalZonePostPatch streamKeyvalZoneKeyValue, string streamKeyvalZoneName, System.Threading.CancellationToken cancellationToken)
        {
            if (streamKeyvalZoneName == null)
                throw new System.ArgumentNullException("streamKeyvalZoneName");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/stream/keyvals/{streamKeyvalZoneName}");
            urlBuilder_.Replace("{streamKeyvalZoneName}", System.Uri.EscapeDataString(ConvertToString(streamKeyvalZoneName, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(streamKeyvalZoneKeyValue, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PATCH");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204") 
                        {
                            return;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Invalid JSON (*KeyvalFormatError*),\nkey required (*KeyvalFormatError*),\nkeyval timeout is not enabled (*KeyvalFormatError*),\nonly one key can be updated (*KeyvalFormatError*)\n", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Keyval not found (*KeyvalNotFound*),\nkeyval key not found (*KeyvalKeyNotFound*)\n", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Method disabled (*MethodDisabled*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "415") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("JSON error (*JsonError*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Empty the stream keyval zone</summary>
        /// <param name="streamKeyvalZoneName">The name of a stream keyval shared memory zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteStreamKeyvalZoneDataAsync(string streamKeyvalZoneName)
        {
            return DeleteStreamKeyvalZoneDataAsync(streamKeyvalZoneName, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Empty the stream keyval zone</summary>
        /// <param name="streamKeyvalZoneName">The name of a stream keyval shared memory zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteStreamKeyvalZoneDataAsync(string streamKeyvalZoneName, System.Threading.CancellationToken cancellationToken)
        {
            if (streamKeyvalZoneName == null)
                throw new System.ArgumentNullException("streamKeyvalZoneName");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/stream/keyvals/{streamKeyvalZoneName}");
            urlBuilder_.Replace("{streamKeyvalZoneName}", System.Uri.EscapeDataString(ConvertToString(streamKeyvalZoneName, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204") 
                        {
                            return;
                        }
                        else
                        if (status_ == "404") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Keyval not found (*KeyvalNotFound*)\n", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Method disabled (*MethodDisabled*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Return sync status of a node</summary>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<StreamZoneSync> GetStreamZoneSyncAsync()
        {
            return GetStreamZoneSyncAsync(System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return sync status of a node</summary>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<StreamZoneSync> GetStreamZoneSyncAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/stream/zone_sync/");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<StreamZoneSync>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(StreamZoneSync);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Return status for all resolver zones</summary>
        /// <param name="fields">Limits which fields of resolvers statistics will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, ResolverZone>> GetResolverZonesAsync(string fields)
        {
            return GetResolverZonesAsync(fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return status for all resolver zones</summary>
        /// <param name="fields">Limits which fields of resolvers statistics will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, ResolverZone>> GetResolverZonesAsync(string fields, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/resolvers/?");
            if (fields != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(fields, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.IDictionary<string, ResolverZone>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(System.Collections.Generic.IDictionary<string, ResolverZone>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Return statistics of a resolver zone</summary>
        /// <param name="fields">Limits which fields of the resolver zone will be output (requests, responses, or both).</param>
        /// <param name="resolverZoneName">The name of a resolver zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ResolverZone> GetResolverZoneAsync(string fields, string resolverZoneName)
        {
            return GetResolverZoneAsync(fields, resolverZoneName, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return statistics of a resolver zone</summary>
        /// <param name="fields">Limits which fields of the resolver zone will be output (requests, responses, or both).</param>
        /// <param name="resolverZoneName">The name of a resolver zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ResolverZone> GetResolverZoneAsync(string fields, string resolverZoneName, System.Threading.CancellationToken cancellationToken)
        {
            if (resolverZoneName == null)
                throw new System.ArgumentNullException("resolverZoneName");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/resolvers/{resolverZoneName}?");
            urlBuilder_.Replace("{resolverZoneName}", System.Uri.EscapeDataString(ConvertToString(resolverZoneName, System.Globalization.CultureInfo.InvariantCulture)));
            if (fields != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(fields, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ResolverZone>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "404") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Resolver zone not found (*ResolverZoneNotFound*)\n", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(ResolverZone);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Reset statistics for a resolver zone.</summary>
        /// <param name="resolverZoneName">The name of a resolver zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteResolverZoneStatAsync(string resolverZoneName)
        {
            return DeleteResolverZoneStatAsync(resolverZoneName, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Reset statistics for a resolver zone.</summary>
        /// <param name="resolverZoneName">The name of a resolver zone.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteResolverZoneStatAsync(string resolverZoneName, System.Threading.CancellationToken cancellationToken)
        {
            if (resolverZoneName == null)
                throw new System.ArgumentNullException("resolverZoneName");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/resolvers/{resolverZoneName}");
            urlBuilder_.Replace("{resolverZoneName}", System.Uri.EscapeDataString(ConvertToString(resolverZoneName, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204") 
                        {
                            return;
                        }
                        else
                        if (status_ == "404") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Resolver zone not found (*ResolverZoneNotFound*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NginxError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<NginxError>("Method disabled (*MethodDisabled*)", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Return SSL statistics</summary>
        /// <param name="fields">Limits which fields of SSL statistics will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SSLObject> GetSslAsync(string fields)
        {
            return GetSslAsync(fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Return SSL statistics</summary>
        /// <param name="fields">Limits which fields of SSL statistics will be output.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<SSLObject> GetSslAsync(string fields, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/ssl?");
            if (fields != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(fields, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SSLObject>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(SSLObject);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Reset SSL statistics</summary>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteSslStatAsync()
        {
            return DeleteSslStatAsync(System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Reset SSL statistics</summary>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteSslStatAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/ssl");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204") 
                        {
                            return;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }
    
            public T Object { get; }
    
            public string Text { get; }
        }
    
        public bool ReadResponseAsString { get; set; }
        
        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }
        
            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    using (var streamReader = new System.IO.StreamReader(responseStream))
                    using (var jsonTextReader = new Newtonsoft.Json.JsonTextReader(streamReader))
                    {
                        var serializer = Newtonsoft.Json.JsonSerializer.Create(JsonSerializerSettings);
                        var typedBody = serializer.Deserialize<T>(jsonTextReader);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }
    
        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value is System.Enum)
            {
                string name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute)) 
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }
                }
            }
            else if (value is bool) {
                return System.Convert.ToString(value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[]) value);
            }
            else if (value != null && value.GetType().IsArray)
            {
                var array = System.Linq.Enumerable.OfType<object>((System.Array) value);
                return string.Join(",", System.Linq.Enumerable.Select(array, o => ConvertToString(o, cultureInfo)));
            }
        
            return System.Convert.ToString(value, cultureInfo);
        }
    }
}

#pragma warning restore 1591
#pragma warning restore 1573
#pragma warning restore  472
#pragma warning restore  114
#pragma warning restore  108